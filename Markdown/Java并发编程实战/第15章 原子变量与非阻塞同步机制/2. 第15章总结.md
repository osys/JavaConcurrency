* 比较并交换(compare-and-swap)：当多个线程试图使用比较并交换(CAS)，同时更新相同的变量时，其中一个线程会胜出，并且更新变量的值，而其它的线程都会失败。失败的线程允许尝试再次比较并交换操作。一个线程在竞争 CAS 时失败，不会被阻塞，它可以决定是否重试，这样的灵活性大大减少了锁相关的活跃度风险。
* 原子变量类，提供了广义的 volatile 变量，以支持原子的、条件的读-写-改操作。原子变量是“更佳的volatile”
* 原子变量比锁更精巧，更轻量，并且在多处理器系统中，对实现高性能的并发代码非常关键。在使用原子变量取代锁的算法中，线程更不易出现延迟，如果它们遇到竟争，也更容易恢复。
* 锁与原子化随竞争度的不同，性能发生的改变阐明了各自的优势和劣势。在中低程度的竞争下，原子化提供更好的可伸缩性；在高强度的竞争下，锁能够更好地帮助我们避免竞争。
* 非阻塞(nonblocking)算法：一个线程的失败或挂起不应该影响其他线程的失败或挂起
* 锁自由(lock-frce)算法：如果算法的每一步骤中都有一些线程能够继续执行，那么这样的算法称为锁自由算法。
* 本章还介绍了非阻塞链表、非阻塞栈两个经典例子。

