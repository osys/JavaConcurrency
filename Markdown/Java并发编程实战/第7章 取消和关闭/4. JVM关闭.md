## 1. JVM 关闭

* JVM既可以正常关闭也可以强行关闭。
* 正常关闭的触发方式有多种，包括：当最后一个“非守护“线程结束时，或者调用System.exit时，或者通过其他特定平台的方法关闭时(如：`Crtl+C`、发送signet信号 等)



## 2. 关闭钩子

`关闭钩子`：是指通过 `Runtime.addShutdownHook` 注册的但尚未开始的线程。

1. 在正常关闭中，JVM首先调用所有已注册的关闭钩子(Shutdown hook)。
2. JVM并不能保证关闭钩子的调用顺序。
3. 在关闭应用程序线程中，如果线程仍然在运行，那么这些线程接下来和关闭进程并发执行。
4. 如果 `runFinalizerOnExit` 为 `true`。那么JVM将运行终结器，然后再停止。
5. JVM并不会停止或中断任何在关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。
6. 如果关闭钩子或终结器没有执行完成，那么正常关闭进程“挂起”并且JVM必须被强行关闭。
7. 当强行关闭时，只是关闭JVM，而不会运行关闭钩子。



关闭钩子应该是线程安全的：

* 它们在访问共享数据时必须使用同步机制，并且小心的避免死锁，这和其他并发代码的要求相同。
* 而且，关闭钩子不应该对应用程序的状态或者JVM的关闭原因作出任何假设。
* 最后，关闭钩子应该尽快退出，因为它们会延迟JVM的结束时间，而用户可能希望JVM尽快终止。

关闭钩子可以用于实现服务或应用程序的清理工作，例如清理临时文件。



由于关闭钩子将并发执行，因此在关闭日志文件时可能导致其他需要日志服务的关闭钩子产生问题。实现这种功能的一种方式是对所有服务使用同一个关闭钩子，并且在关闭钩子中执行一系列的关闭操作。

> 注册关闭钩子来停止日志服务

```java
public void start(){
    Runtime.getRuntime().addShutdownHook(new Thread(){
        public void run(){
            try{
                LogService.this.stop();
            } catch(InterruptedException ignored){
                
            }
        }
    }
}
```



## 3. 守护线程

* 线程分为两种：`普通线程` 和 `守护线程`。
* 在JVM启动时创建的所有线程中，除了主线程，其他都是守护线程(例如GC等)。



普通线程和守护线程的差异仅仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，JVM会正常退出操作，当JVM停止时，所有仍然存在的守护线程都将被抛弃 ---- 既不会执行 finally 代码块，也不会执行回卷栈，而JVM只是直接退出。

> 此外，守护线程通常不能用来代替应用程序管理程序中各个服务的生命周期。



## 4. 终结器 `Finalize`

* 当不再需要内存资源时，可以通过GC来回收他们，但对于其他一些资源，例如文件句柄或套接字句柄，必须显式的还给操作系统。

* 为了实现这个功能，垃圾回收器对那些定义了 `finalize()` 方法的对象会进行特殊处理：在回收器释放它们后，调用它们的 finalize 方法，从而保证一些持久化资源被释放。

    ```java
    public class Object {
        protected void finalize() throws Throwable { }
    }
    ```

    

由于 `终结器` 可以在某个由JVM管理的线程中运行因此终结器访问的任何状态都可能被多个线程访问，这样就必须对其访问操作进行同步。

在大多数情况下，通过 `finally 代码块` 和 `显式的 close()` 方法，能够比使用终结器更好的管理资源。唯一的例外是：当需要管理对象，并且该对象持有的资源是通过本地方法获得的。

> 避免使用终结器。

