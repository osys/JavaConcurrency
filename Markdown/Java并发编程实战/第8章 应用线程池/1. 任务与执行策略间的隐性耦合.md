## 1. 在任务与执行策略之间的隐性耦合

Executor 框架可以将`任务的提交`与`任务的执行`策略解耦开来。Executor 框架为制定和修改执行策略提供了相当大的灵活性，但**并非所有的任务都能适用所有的执行策略**。 有些类型的任 务需要明确地指定执行策略， 包括：

1. 依赖性任务：简单来说就是，提交的 `task` 是需要依赖 `其它任务` 的， `task` 就类似有某种枷锁一样，浑身不自在。

    * 大多数任务都是独立的，它们不依赖于其他任务的执行时序、 执行结果或其他效果。 
    * 当在线程池中执行独立的任务时， 可以随意地改变线程池的大小和配置，这些修改只会对执行性能产生影响。
    * 如果提交给线程池的任务需要依赖其他的任务， 那么就隐含地给执行策略带来了约束， 此时必须小心地维持这些执行策略，以避免产生活跃性问题。

    

2. 采用线程封闭机制的任务：

    * 在单线程中的 Executor：能够对并发性做出更强的承诺。 它们能确保任务不会并发地执行， 使我们能够放宽代码对线程安全的要求。`对象`可以封闭在 `task 所在的线程`中， 使得在`该线程`中执行的 task 在访问该对象时不需要同步， 即使这些资源不是线程安全的也没有问题。 
    * Executor 从单线程环境改为线程池环境，任务可能会被并发地执行，失去了线程安全性。

    

3. 对响应时间敏感的任务：

    * GUI应用程序对于响应时间是敏感的：如果用户在点击按钮后需要很长延迟才能得到可见的反馈， 那么他们会感到不满。

    * 如果将一个运行时间较长的任务提交到单线程的Executor中， 或者将多个运行时间较长的任务提交到一个只包含少量线程的线程池 中， 那么将降低由该Executor管理的服务的响应性。

        

4. 使用ThreadLocal的任务：

    * ThreadLocal使每个线程都可以拥有某个变量的一个私有`版本`。然而，只要条件允许，Executor可以自由地重用这些线程。
    * 在标准的Executor实现中，当执行需求较低时将回收空闲线程，而当需求增加时将添加新的线程，并且如果从任务中抛出了一个未检查异常，那么将用一个新的工作者线程来替代抛出异常的线程。
    * 只有当线程本地值的生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义。
    * 在线程池的线程中不应该使用 ThreadLocal在任务之间传递值。

只有当任务都是同类型的并且相互独立时，线程池的性能才能达到最佳。如果将运行时间较长的与运行时间较短的任务混合在一起，那么除非线程池很大，否则将可能造成`拥塞`。如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成`死锁`。



### 1.1 线程饥饿死锁

* 在多线程中，如果某个线程任务，依赖于其它任务的执行，那么就有可能会产生线程死锁。

* 在单线程的 Executor 中，如果一个任务将另一个任务提交到同一个 Executor，并且等待这个被提交任务的结果，那么通常会引发死锁。

    第二个任务停留在工作队列中，并等待第一个任务完成，而第一个任务又无法完成，因为它在等待第二个任务的完成。



> 在单线程化的 Executor 中死锁的任务

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * <p><b>{@link ThreadDeadlock} Description</b>: 在单线程化的 Executor 中死锁的任务。
 * </p>
 * <p>Created by lyh on 2022/06/17 00:11.</p>
 */
public class ThreadDeadlock {
    // single executor
    ExecutorService exec = Executors.newSingleThreadExecutor();

    public class LoadFileTask implements Callable<String> {
        private final String fileName;

        public LoadFileTask(String fileName) {
            this.fileName = fileName;
        }

        public String call() throws Exception {
            // 读取文件
            return "";
        }
    }

    public class RenderPageTask implements Callable<String> {
        public String call() throws Exception {
            Future<String> header, footer;
            header = exec.submit(new LoadFileTask("header.html"));
            footer = exec.submit(new LoadFileTask("footer.html"));
            String page = renderBody();

            return header.get() + page + footer.get();
        }

        private String renderBody() {
            // 页面渲染
            return "";
        }
    }
    
    public void test() {
        RenderPageTask mainTask = new RenderPageTask();
        exec.submit(mainTask);
    }
}
```

例子 `ThreadDeadlock.RenderPageTask` 将两个 LoadFileTask 添加到单例的 ExecutorService 中。在 `tast()` 中，我们将 `RenderPageTask` 添加到单例的 ExecutorService 中，那么会出现 mainTask 等待其他两个 LoadFileTask 的结果，久久不能结束，而那两个 LoadFileTask 却需要等待 mainTask 结束才能被单例的 ExecutorService 执行（久久不能开始）。



### 1.2 耗时操作

* 执行时间较长的任务不仅会造成线程池堵塞，甚至还会增加执行时间较短任务的服务时间。

* 如果线程池中线程的数量远小于在稳定状态下执行时间较长任务的数量， 那么到最后可能所有的线程都会运行这些执行时间较长的任务， 从而影响整体的响应性。

* 限定任务等待资源的时间， 而不要无限制地等待。

    例如 Thread.join、BlockingQueue.put、CountDownLatch.await 以及 Selector.select 等。



## 2. 定制线程池的大小

在代码中通常不会固定线程池的大小。线程池的长度应该通过某种配置机制来提供，或者根据 `Runtime.availableProcessors()` 来动态计算。

```java
public class Runtime {
    // 返回 Java 虚拟机可用的处理器数量。 int > 0
    public native int availableProcessors();
}
```

* 要设置线程池的大小，需要避免【过大】和【过小】这两种极端情况。
* 如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源。
* 如果线程池过小，那么将导致许多空闲的处理器无法执行工作，从而降低吞吐率。
* 如果需要执行不同类别的任务，井且它们之间的行为相差很大，那么应该考虑使用多个线程池，从而使每个线程池可以根据各自的工作负载来调整。



大小设定公式：

```
最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目
```



