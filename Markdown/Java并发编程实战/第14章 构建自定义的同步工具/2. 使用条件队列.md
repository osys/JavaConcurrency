条件队列让构建有效且响应的状态依赖类变得更容易，但是使用时比较容易出错。应该尽量构建在像 LinkedBlockingQueue、Latch、Semaphore 和 FutureTask 基础之上。



## 1. 条件谓词

* 条件调词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系。
* 在有限缓存中，只有缓存不为空时 take 才能执行，否则它必须等待。就 take 而言，它的条件谓词是“绶存不空”，take 执行前必须先测试。类似地，put 的条件谓词是“缓存不满”。

* 在条件等待中存在一种重要的三元关系，包括：加锁、wait() 方法、条件谓词

每次调用 wait 都会您式地与特定的永什调调相关联。当调用特定条件谓词的 wait 时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量。



## 2. 过早地唤醒

当线程A调用到 wait() 代码后，其它线程在此期间插足了 ---- 获取了锁，并且修改了数据。那么线程A获取锁后，需要重新检查条件谓词。例如：

```java
public synchronized void put(V v) throws InterruptedException {
    // 条件谓词：isFull()
    while (isFull()) {
        wait();
    }
    doPut(v);
    notifyAll();
}

public synchronized V take() throws InterruptedException {
    // 条件谓词：isEmpty()
    while (isEmpty()) {
        wait();
    }
    V v = doTake();
    notifyAll();
    return v;
}
```

【线程A】调用空缓存中的 take()，不满足条件（绶存不空），于是调用 wait() 使当前线程等待。

【线程B】调用该空缓存中的 put()，满足条件（缓存不满），于是将一个元素放入缓存，并且调用 notifyAll()，唤醒【线程A】。

【线程A】此时需要再次检查条件谓词是否满足。



不过有的时候，我们可能根本不知道哪个方法调用了 notify() 或 notifyAll()，唤醒正在 wait() 的线程。如果被唤醒的线程去检查条件谓词，还不能满足条件，就又要继续等待。

> 状态依赖方法的规范式

```java
void stateDependentMethod() throws InterruptedException {
    // 条件谓词必须被锁守护
    synchronized(lock) {  
        while (!conditionPredicate()) {
            lock.wait();
        }
        // 现在，对象处于期望的状态中
    }
} 
```



当使用条件等待时(Object.wait 或者 Condition.await)

* 永远设置一个条件谓词 ---- 一些对象状态的测试，线程执行前必须满足它；
* 永远在调用 wait 前测试条件谓词，并且从 wait 中返回后再次测试；
* 永远在循环中调用 wait；
* 确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；
* 当调用 wait、 notify 或者 notifyAll 时，要持有与条件队列相关联的锁；并且在检查条件谓词之后、开始执行被保护的逻辑之前，不要释放锁。



## 3. 丢失的信号

保证 `notify()` 一定在 `wait()` 之后。



## 4. 通知

* 在有限缓存中，在绶存变为非空时，为了能够让 take 解除阻塞，我们必须确保每一条能够让缓存变为非空的代码路径都执行一个通知。

    例如：

    ```java
    public synchronized void alternatePut(V v) throws InterruptedException {
        while (isFull()) {
            wait();
        }
        boolean wasEmpty = isEmpty();
        doPut(v);
        if (wasEmpty) {
            notifyAll();
        }
    }
    ```

    向有限缓存中添加一个元素，在最后调用 notifyAll() 通知正在 wait() 的线程。

* 对于 notify() 和 notifyAll() 无论调用哪一个，都必须持有与条件队列对象相关联的锁。

    * 调用 notify() 的结果是：JVM 会从在这个条件队列中等待的众多线程中挑选出一个，并把它唤醒。
    * 而调用 notifyAll() 会唤醒所有正在这个条件队列中等待的线程。
    * 由于调用 notify() 和 notifyAll() 时必须持有条件队列对象的锁，这导致等待线程此时不能重新获得锁，无法从 wait() 返回，因此该通知线程应该尽快释放锁，以确保等待线程尽可能快地解除阻塞。

* 推荐使用 notifyAll()，因为多个线程可能会由于不同的原因在同一个条件队列中等待，调用 notifyAll() 会唤醒所有，而调用 notify() 只会由 JVM 挑选一个唤醒。



## 5. 阀门类

> 开始阀门闭锁(starting gate latch)

二元闭锁：

```java
import java.util.concurrent.CountDownLatch;

/**
 * 在时序测试中，使用 CountDownLatch 来启动和停止线程
 *
 * CountDownLatch.class ---- 利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。
 */
public class TestHarness {
    /**
     * 使用 CountDownLatch 来启动和停止线程
     * @param nThreads 要启动的线程数
     * @param task 线程任务
     * @return 线程等待，释放时间
     * @throws InterruptedException 当线程等待、休眠或以其他方式被占用，并且线程在活动之前或期间被中断时抛出
     */
    public long timeTasks(int nThreads, final Runnable task)
            throws InterruptedException {
        // 在线程可以通过await()方法之前，计数值为1，需调用countDown()方法的次数为1次
        final CountDownLatch startGate = new CountDownLatch(1);
        // 在线程可以通过await()方法之前，计数值为 nThreads，需调用countDown()方法的次数为 nThreads 次
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        // 通过await()方法需满足：锁计数器为0、线程被中断、或者超过指定的等待时间
        // 每调用countDown()方法，计数器减1

        for (int i = 0; i < nThreads; i++) {
            Thread aThread = new Thread() {
                @Override
                public void run() {
                    try {
                        // 线程等待
                        startGate.await();
                        try {
                            // 启动线程
                            task.run();
                        } finally {
                            // 减少锁存器的计数，如果计数达到零，则释放所有等待线程
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) {}
                }
            };
            aThread.start();
        }

        long start = System.nanoTime();
        // startGate 锁计数器(原本定义为1)，现在调用 countDown() 方法，减去1
        // 此时，startGate 的锁计数器为0，可以通过 await() 方法了
        // 因此就可以到达 task.run()
        startGate.countDown();
        // endGate 锁计数器原本定义为nThreads，也就是线程个数。
        // 程序未出现异常情况，需要调用 countDown() 方法 nThreads 次
        // endGate.countDown() 方法在每个线程的 finally {...} 中
        // 因此需要 nThreads 个线程都完成，才能使得 锁计数器=0，这个时候才能通过 endGate.await() 方法
        endGate.await();
        long end = System.nanoTime();
        return end - start;
    }
}
```

这里通过将计数器初始化为1，创建了一个二元闭锁：它只有两种状态，初始状态和终止状态。闭锁会阻止线程通过开始阀门，直到阀门被打开，此时所有的线程都可以通过。



> 使用 wait 和 notifyAll 实现可重关闭的阀门

```java
import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

@ThreadSafe
public class ThreadGate {
    // 条件谓词: opened-since(n) (isOpen || generation>n)
    @GuardedBy("this")
    private boolean isOpen;
    @GuardedBy("this")
    private int generation;

    public synchronized void close() {
        isOpen = false;
    }

    public synchronized void open() {
        ++generation;
        isOpen = true;
        notifyAll();
    }

    // 阻塞，直到: opened-since(generation on entry)
    public synchronized void await() throws InterruptedException {
        int arrivalGeneration = generation;
        while (!isOpen && arrivalGeneration == generation) {
            wait();
        }
    }
}
```



## 6. 显式的 Condition 对象

Lock 是一个广义的内置锁，而 Condition 也是一种广义的 **内置条件队列**。

```java
package java.util.concurrent.locks;

public interface Condition {
  	/** 使当前线程等待，直到它发出信号或被中断。 */
  	void await() throws InterruptedException;
    
    /** 使当前线程一直等待，直到它发出信号或中断，或者指定的等待时间过去。 */
  	boolean await(long time, TimeUnit unit)throws InterruptedException;
    
    /** 使当前线程一直等待，直到它发出信号或中断，或者指定的等待时间过去。 */
  	long awaitNanos(long nanosTimeout) throws InterruptedException;
    
    /** 导致当前线程等待，直到它发出信号。 */
  	void awaitUninterruptibly();
    
    /** 使当前线程等待，直到它发出信号或中断，或指定的截止日期过去。 */
  	boolean awaitUntil(Date deadline) throws InterruptedException;
    
    /**  唤醒一个等待线程。*/
  	void signal();
    
    /** 唤醒所有等待的线程。 */
  	void signalAll();
}
```



* 内部条件队列有一些缺陷。每个内部锁只能有一个与之相关联的条件队列，多个线程可能为了不同的条件谓词在同一个条件队列中等待，而且大多数常见的锁模式都会暴露条件队列对象。这些因素都导致不可能为了使用notifyAll()，而强迫等待线程统一。
* 如果想编写一个带有多个条件谓词的并发对象，或者想获得除了条件队列可见性之外的更多的控制权，可以使用Lock和Condition，而不是内置锁和内置条件队列。
* 一个 Conaition 和一个单独的 Lock 相关联，就像条件队列和单独的内部锁相关联一样；调用与 Condition 相关联的 Lock 的 Lock.newConaition() 方法，可以创建一个 Conaition。如同 Lock 提供了比内部加锁要丰富得多的特征集一样，Condition 也提供了比内部条件队列要丰富得多的特征集：每个锁可以有多个等待集、可中断/不可中断的条件等待、基于时限的等待以及公平/非公平队列之间的选择。
* 不同于内部条件队列，你可以让每个 Lock 都有任意数量的 Condition 对象。



> 警告: Object 的 wait()、notify() 和notifyAll()方法在 Conaition 中的对等体是 await()、 signal() 和 BignalAll()。
>
> 但是 Condition 继承自 Object，这意味着它也有 wait() 和 notify() 方法。
>
> 一定要确保使用了正确的版本 ---- await() 和 signal()



有限缓存使用显式的条件变量：

```java
import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

@ThreadSafe
public class ConditionBoundedBuffer <T> {
    protected final Lock lock = new ReentrantLock();
    
    // 条件谓词: notFull (count < items.length)
    private final Condition notFull = lock.newCondition();
    // 条件谓词: notEmpty (count > 0)
    private final Condition notEmpty = lock.newCondition();
    
    private static final int BUFFER_SIZE = 100;
    @GuardedBy("lock")
    private final T[] items = (T[]) new Object[BUFFER_SIZE];
    @GuardedBy("lock")
    private int tail, head, count;

    // 阻塞，直到: notFull
    public void put(T x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length) {
                notFull.await();
            }
            items[tail] = x;
            if (++tail == items.length) {
                tail = 0;
            }
            ++count;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    // 阻塞直到: notEmpty
    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await();
            }
            T x = items[head];
            items[head] = null;
            if (++head == items.length) {
                head = 0;
            }
            --count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```

Condition 简化了使用单一通知的条件。使用更有效的 signal()，而不是 signalAll()，这就会减少相当数量的上下文转换，而且每次缓存操作都会触发对锁的请求。

