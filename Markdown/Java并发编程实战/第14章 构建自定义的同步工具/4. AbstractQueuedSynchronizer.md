## 1. AbstractQueuedSynchronizer

* 一个基于 AQS 的 synchronizer 所执行的基本操作，是一些不同形式的获取(acquire） 和释放（release）。

* AQS 管理着一个广域状态信息的单一整数，状态信息可以通过 getState()、setState()、compareAndSetState()等方法进行操作

    ```java
    // 返回同步状态的当前值。此操作具有volatile读取的内存语义
    protected final int getState() {
    	return state;
    }
    
    // 设置同步状态的值。此操作具有volatile写入的内存语义
    protected final void setState(int newState) {
        state = newState;
    }
    
    // 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值。此操作具有volatile读写的内存语义
    protected final boolean compareAndSetState(int expect, int update) {
        // ...
    }
    ```

    * ReentrantLock 用它来表现拥有它的线程已经请求了多少次锁
    * Semaphore 用它来表现剩余的许可数
    * Futurerask 用它来表现任务的状态（尚未开始、运行、完成和取消）

* AQS中获取和释放操作的规范式

    ```java
    boolean acquire() throws InterruptedException {
        while (状态不允许获取) {
            if (阻止获取请求) {
                如果尚未排队阻塞当前线程，
        	} else {
                否则则将当前线程入队
          		return failure
        	}
      	}
      	可能更新同步状态
    	如果线程已排队，则使线程出队
      	return success
    }
    
    void release() {
      	更新同步状态
      	if (新状态可能允许被阻塞的线程获取) {
            解除阻塞一个或多个排队线程
        }
    }
    ```

    一个获取操作分为两步。第一步，Synchronizer 判断当前状态是否允许被获得：如果是，就让线程执行，如果不是，获取操作阻塞或失败。第二步包括了可能需要更新的状态；一个想获取 synchronizer 的线程会影响到其他线程是否能够获取它。

* 一个简单的闭锁

    ```java
    import net.jcip.annotations.ThreadSafe;
    
    import java.util.concurrent.locks.AbstractQueuedSynchronizer;
    
    @ThreadSafe
    public class OneShotLatch {
        private final Sync sync = new Sync();
    
        public void signal() {
            sync.releaseShared(0);
        }
    
        public void await() throws InterruptedException {
            sync.acquireSharedInterruptibly(0);
        }
    
        private class Sync extends AbstractQueuedSynchronizer {
            protected int tryAcquireShared(int ignored) {
                // 如果闭锁打开(state == 1)则成功，否则失败
                return (getState() == 1) ? 1 : -1;
            }
    
            protected boolean tryReleaseShared(int ignored) {
                setState(1); // 闭锁现已打开
                return true; // 其他线程现在可能能够获取
            }
        }
    }
    ```

    

## 2. ReentrantLock

ReentrantLock 只支持独占的获取操作，因此它实现了 tryAcquire()、 tryRelease() 和 isHeldExclusively()

```java
public class ReentrantLock implements Lock, java.io.Serializable {
    abstract static class Sync extends AbstractQueuedSynchronizer {
        // 执行不公平的 tryLock
        final boolean nonfairTryAcquire(int acquires) {
            // ......
        }
        // 尝试设置状态以反映独占模式下的发布
        protected final boolean tryRelease(int releases) {
            // ......
        }
        // 如果同步仅针对当前（调用）线程进行，则返回true 
        protected final boolean isHeldExclusively() {
            // ......
        }
    }
    
    static final class NonfairSync extends Sync {
        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
    }
}
```



> 非公平的 ReentrantLock 中 tryAcquire 的实现

```java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    // 同步状态的当前值
    int c = getState();
    if (c == 0) {
        // 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值
        if (compareAndSetState(0, acquires)) {
            // 设置当前拥有独占访问权限的线程
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 返回最后由setExclusiveOwnerThread设置的线程，如果从未设置，则返回null 
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        // 设置同步状态的值
        setState(nextc);
        return true;
    }
    return false;
}
```



## 3. Semaphore 和 CountDownLatch

>Semaphore

Semaphore 使用 AQS 类型的同步状态持有当前可用许可的数量。Semaphore 的 tryAcquireShared 和 tryAcquire Shared 方法:

```java
public class Semaphore implements java.io.Serializable {
    abstract static class Sync extends AbstractQueuedSynchronizer {
        // ......
        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                // 同步状态的当前值
                int available = getState();
                int remaining = available - acquires;
                // 剩余状态量小于零
                if (remaining < 0 ||
                    // 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
        
        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                // 同步状态的当前值
                int current = getState();
                int next = current + releases;
                if (next < current) // overflow
                    throw new Error("Maximum permit count exceeded");
                // 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值
                if (compareAndSetState(current, next))
                    return true;
            }
        }
        // ......
    }
    
    static final class NonfairSync extends Sync {
        // ......
        protected int tryAcquireShared(int acquires) {
            return nonfairTryAcquireShared(acquires);
        }
    }
}
```

* nonfairTryAcquireShared() 方法：首先计算剩余许可的数量，如果没有足够的许可，会返回一个值，表明获取操作失败。如果还有充足的许可剩余，nonfairTryAcquireShared 会使用 compareAndsetState()，尝试原子地递减许可的计数。
* 类似地，tryReleaseShared() 会递增许可计数，这会潜在地解除等待中的线程的阻塞，不断地重试直到成功地更新。tryReleaseShared 的返回值表明，释放操作是否可以解除其他线程的阻塞。



>CountDownLatch

CountDownLatch 使用 AQS 的方式与 Semaphore 相似，同步状态持有当前的计数：

* countDown 方法调用 release，后者会导致计数器递减，并且在计数器已经到达零的时候，解除所有等待线程的阻塞

    ```java
    protected boolean tryReleaseShared(int releases) {
        // 递减计数；转换为零时的信号
        for (;;) {
            // 同步状态的当前值
            int c = getState();
            if (c == 0)
                return false;
            int nextc = c-1;
            // 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值
            if (compareAndSetState(c, nextc))
                return nextc == 0;
        }
    }

* await 调用 acquire，如果计数器己经到达零，acquire 会立即返回，否则它会被阻塞。

    ```java
    protected int tryAcquireShared(int acquires) {
        return (getState() == 0) ? 1 : -1;
    }
    ```



## 4. ReentrantReadWriteLock

>ReentrantReadWriteLock

```java
public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable {
    private final ReentrantReadWriteLock.ReadLock readerLock;
    private final ReentrantReadWriteLock.WriteLock writerLock;
    
    abstract static class Sync extends AbstractQueuedSynchronizer {
        static final int SHARED_SHIFT   = 16;
        
        protected final boolean tryRelease(int releases) {
            // ......
        }
        protected final boolean tryAcquire(int acquires) {
            // ......
        }
    }
}
```

ReadwriteLock 的接口要求了两个锁，一个读者锁和一个写者锁。在基于 AQS 的 ReentrantReadMriteLock 实现中，一个单独的 AQS 子类管理了读和写的加锁。

ReentrantReadwriteLock 使用一个 16 位的状态为写锁（write-lock）计数，使用另一个 16 位的状态为读锁(read-lock）计数。

对读锁的操作使用共享的获取与释放的方法：对写锁的操作使用独占的获取与释放的方法。