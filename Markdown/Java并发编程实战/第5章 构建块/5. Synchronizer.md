## 1. Synchronizer

`Synchronizer` 是一个对象，它根据本身的状态`调节`线程的`控制流`。

Synchronizer对象包含：`BlockingQueue（阻塞队列）`，`Semaphore（信号量）`、`Barrier（关卡）`、`闭锁（Latch）`。



## 2. `阻塞队列(BlockingQueue)`

* 阻塞队列在容器类中，不仅作为对象的容器，而且能够`协调`生产者线程和消费者线程之间的`控制流`。
* 因为 `take` 和 `put` 会保持阻止状态直到队列进入了期望的状态（队列元素不为空，队列还能存放元素）。



## 3. `闭锁(Latch)`

`闭锁`是一种 `Synchronizer`，它可以`延迟`线程的进度直到线程到达`终止状态`。

`闭锁`工作起来就像大门：直到闭锁达到终点状态之前，门一直是关闭的，没有线程能够通过，在终点状态到来的吋候，门开了，允许所有线程都通过。

一但闭锁到达了终点状态，它就不能够再改变状态了，所以它会永远保持敞开状态。

闭锁可以用来确保特定活动直到其他的活动完成后才发生，比如：

* 确保一个计算不会执行，直到它需要的资源被初始化。
* 确保一个服务不会开始，直到它依赖的其他服务都已经开始。
* 等待，直到活动的所有部分都为继续处理作好充分准备，比如在多玩家的游戏中的所有玩家是否都准备就绪。这样的闭锁会在所有玩家准备就绪时，达到终点状态。



> FutureTask

- Futurerask 可以作为闭锁。
- FutureTask 实现了 Future 接口和 `Runnable` 接口，它等价于一个携带结果的 Runnable，并且有三个状态：`等待`、`运行`、`完成`
- 完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。一旦 FutureTask 进入完成状态，它会永远停止在这个状态上。



> 在时序测试中，使用 CountDownLatch 来启动和停止线程

```java
import java.util.concurrent.CountDownLatch;

/**
 * 在时序测试中，使用 CountDownLatch 来启动和停止线程
 *
 * CountDownLatch.class ---- 利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。
 * @author osys
 */
public class TestHarness {
    /**
     * 使用 CountDownLatch 来启动和停止线程
     * @param nThreads 要启动的线程数
     * @param task 线程任务
     * @return 线程等待，释放时间
     * @throws InterruptedException 当线程等待、休眠或以其他方式被占用，并且线程在活动之前或期间被中断时抛出
     */
    public long timeTasks(int nThreads, final Runnable task)
            throws InterruptedException {
        // 在线程可以通过await()方法之前，计数值为1，需调用countDown()方法的次数为1次
        final CountDownLatch startGate = new CountDownLatch(1);
        // 在线程可以通过await()方法之前，计数值为 nThreads，需调用countDown()方法的次数为 nThreads 次
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        // 通过await()方法需满足：锁计数器为0、线程被中断、或者超过指定的等待时间
        // 每调用countDown()方法，计数器减1

        for (int i = 0; i < nThreads; i++) {
            Thread aThread = new Thread() {
                @Override
                public void run() {
                    try {
                        // 线程等待
                        startGate.await();
                        try {
                            // 启动线程
                            task.run();
                        } finally {
                            // 减少锁存器的计数，如果计数达到零，则释放所有等待线程
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) {}
                }
            };
            aThread.start();
        }

        long start = System.nanoTime();
        // startGate 锁计数器(原本定义为1)，现在调用 countDown() 方法，减去1
        // 此时，startGate 的锁计数器为0，可以通过 await() 方法了
        // 因此就可以到达 task.run()
        startGate.countDown();
        // endGate 锁计数器原本定义为nThreads，也就是线程个数。
        // 程序未出现异常情况，需要调用 countDown() 方法 nThreads 次
        // endGate.countDown() 方法在每个线程的 finally {...} 中
        // 因此需要 nThreads 个线程都完成，才能使得 锁计数器=0，这个时候才能通过 endGate.await() 方法
        endGate.await();
        long end = System.nanoTime();
        return end - start;
    }
}
```



> 使用 FutureTask 顶载稍后需要的數据

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * 使用 FutureTask 顶载稍后需要的數据
 * @author osys
 */
public class Preloader {
    /** 加载产品信息 */
    ProductInfo loadProductInfo() throws DataLoadException {
        return null;
    }

    /** 创建一个FutureTask ，它将在运行时执行给定的Callable */
    private final FutureTask<ProductInfo> future = new FutureTask<>(new Callable<ProductInfo>() {
            @Override
            public ProductInfo call() throws DataLoadException {
                return loadProductInfo();
            }
        });

    private final Thread thread = new Thread(future);

    public void start() { thread.start(); }

    public ProductInfo get()
            throws DataLoadException, InterruptedException {
        try {
            // 为已完成的任务返回结果或抛出异常（Callable执行结果或异常）
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException) {
                throw (DataLoadException) cause;
            } else {
                throw LaunderThrowable.launderThrowable(cause);
            }
        }
    }

    interface ProductInfo {
    }
}

/** 数据加载异常 */
class DataLoadException extends Exception { }

/** Throwable 强制转换为 RuntimeException */
class LaunderThrowable {

    /**
     * 将未经检查的 Throwable 抛出。
     *
     * 如果 throwable 是 RuntimeException 则返回 Throwable。
     * 如果 throwable 是 Error 则抛出 Error。
     * 否者抛出 IllegalStateException。
     */
    public static RuntimeException launderThrowable(Throwable throwable) {
        if (throwable instanceof RuntimeException) {
            return (RuntimeException) throwable;
        } else if (throwable instanceof Error) {
            throw (Error) throwable;
        } else {
            throw new IllegalStateException("Not unchecked", throwable);
        }
    }
}
```



## 4. `信号量(Semaphore)`

* **计数信号量** 用来控制能够同时访问某特定资源的活动的数量，或者同时执行某一给定操作的数量。

* 计数信号量可以用来实现资源池或者给定一个容器限定边界。



Semaphore的主要方法：

```java
void acquire() {} 				// 从这个信号量获取一个许可，如果没有许可，线程将被阻塞或者线程被中断
void release() {}				// 释放一个许可，将其返回给信号量
int availablePermits() {}		// 返回此信号量中当前可用的许可数
boolean hasQueuedThreads() {}	// 查询是否有线程正在等待获取
```

* Semaphore中管理着一组虚拟的许可（permit)，许可的初始数量可通过构造函数来指定。
* 在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。
* 如果没有许可，那么 `acquire()` 方法将阻塞直到有许可（或者直到被中断、或者操作超时）。
* 计算信号量的一种简化形式是`二元信号量`，即初始值为1的Semaphore。
* 二元信号量可以用做互`斥体(mutex)`，并具备`不可重入`的加锁语义。



使用信号量来约束容器：

```java
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.Semaphore;

/**
 * 使用信号量来约束容器
 * @author osys
 */
public class BoundedHashSet <T> {
    private final Set<T> set;

    /** 信号量 */
    private final Semaphore semaphore;

    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet<>());
        semaphore = new Semaphore(bound);
    }

    public boolean add(T obj) throws InterruptedException {
        // 从这个信号量获取一个许可
        semaphore.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(obj);
            return wasAdded;
        } finally {
            if (!wasAdded) {
                // 释放许可
                semaphore.release();
            }
        }
    }

    public boolean remove(Object obj) {
        boolean wasRemoved = set.remove(obj);
        if (wasRemoved) {
            // 释放许可
            semaphore.release();
        }
        return wasRemoved;
    }
}
```



## 5. `关卡(Barrier)`

关卡类似于闭锁，它们都能够阻塞一组线程，直到某些事件发生。

关卡与闭锁关键的不同在于，所有线程必须同时到达关卡点，才能继续处理。闭锁等待的是`事件`；关卡等待的是`其他线程`。



> CyclicBarrier

`CyclicBarrier` 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（`关卡点`）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。

* 当线程到达关卡点时，调用`await()`方法，线程会被阻塞，直到所有的线程都到达关卡点。
* 如果所有的线程都到达了关卡点，关卡就会被突破，这样所有的线程都被释放，关卡会重置以备下一次使用。
* 如果对`await()`的方法调用`超时`，或者阻塞中的`线程被中断`，那么关卡就被认为是失败的，所有调用`await()`未完成的线程，都通过`BrokenBarrierException`终止。

CyclicBarrier默认的构造方法是`CyclicBarrier(int parties)`，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。



在一个细胞的自动系统中用 CyclicBarrier 协调计算：

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * 在一个细胞的自动系统中用 CyclicBarrier 协调计算
 * @author osys
 */
public class CellularAutomata {
    /** 细胞 */
    private final Board mainBoard;
    /** 关卡 */
    private final CyclicBarrier barrier;
    /** 工作蛋白 */
    private final Worker[] workers;

    public CellularAutomata(Board board) {
        // 细胞
        this.mainBoard = board;
        // Java 虚拟机可用的处理器数量
        int count = Runtime.getRuntime().availableProcessors();
        // 关卡
        this.barrier = new CyclicBarrier(count, new Runnable() {
                            @Override
                            public void run() {
                                // 细胞提交新 value
                                mainBoard.commitNewValues();
                            }
                        });
        // 工作蛋白
        this.workers = new Worker[count];
        for (int i = 0; i < count; i++) {
            // 设置子细胞
            workers[i] = new Worker(mainBoard.getSubBoard(count, i));
        }
    }

    private class Worker implements Runnable {
        /** 细胞 */
        private final Board board;

        public Worker(Board board) {
            this.board = board;
        }

        @Override
        public void run() {
            // 细胞还没转换好
            while (!board.hasConverged()) {
                for (int x = 0; x < board.getMaxX(); x++) {
                    for (int y = 0; y < board.getMaxY(); y++) {
                        // 设置新的 x，y 值
                        board.setNewValue(x, y, computeValue(x, y));
                    }
                }
                try {
                    // 关卡（细胞所有的位置都转换好了，才可继续）---- 所有线程都运行到这里才可以继续
                    barrier.await();
                } catch (InterruptedException | BrokenBarrierException ex) {
                    return;
                }
            }
        }

        private int computeValue(int x, int y) {
            // 在 (x,y) 里计算新 value
            return 0;
        }
    }

    public void start() {
        // 启动线程
        for (Worker worker : workers) {
            new Thread(worker).start();
        }
        // 等待细胞转换
        mainBoard.waitForConvergence();
    }

    /**
     * 细胞
     */
    interface Board {
        /**
         * x 坐标
         * @return x
         */
        int getMaxX();

        /**
         * y 坐标
         * @return y
         */
        int getMaxY();

        /**
         * x，y 对应的 value
         * @param x x
         * @param y y
         * @return value
         */
        int getValue(int x, int y);

        /**
         * x，y 设置新的 value
         * @param x x
         * @param y y
         * @param value value
         * @return 新 value
         */
        int setNewValue(int x, int y, int value);

        /** 提交新 value */
        void commitNewValues();

        /**
         * 是否转换好
         * @return true/false
         */
        boolean hasConverged();

        /**
         * 等待转换
         */
        void waitForConvergence();

        /**
         * 获取子细胞
         * @param numPartitions 分区
         * @param index 所处分区
         * @return 子细胞
         */
        Board getSubBoard(int numPartitions, int index);
    }
}
```

