## 1. 在线程中执行任务

* 多数并发程序是围绕任务进行管理的，所谓`任务`就是抽象、离散的工作单元。
* 正常情况下，服务器应该兼顾**良好的吞吐量和快速的响应性**。
* 在负荷状况下，应该**平缓的劣化**，不应该快速失败，为了达到这些策略，应该有一个明确的任务执行策略。



## 2. 顺序地执行任务

顺序化地 Web Server

```java
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * Created by osys on 2022/08/28 21:48.
 */
public class SingleThreadWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        // 顺序执行，接受连接，处理连接
        while (true) {
            Socket connection = socket.accept();
            handleRequest(connection);
        }
    }

    private static void handleRequest(Socket connection) {
        // 处理逻辑
    }
}
```

顺序处理`并发性能低`，必须等待一个请求结束才能响应下一个请求。其他线程在等待某个请求处理结束时，CPU可能较为空闲，因此导致资源利用率非常低。



## 3. 显式的为任务创建线程

Web Server为每个请求启动一个新的线程

```java
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * Created by osys on 2022/08/28 21:48.
 */
public class ThreadPerTaskWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        // 并发处理请求
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                @Override
                public void run() {
                    handleRequest(connection);
                }
            };
            new Thread(task).start();
        }
    }

    private static void handleRequest(Socket connection) {
        // 处理逻辑
    }
}
```

主循环为每个连接都创建一个`新线程`以`处理请求`，而`不在主循环`的内部`处理请求`。

结论：

1. 执行任务的负载已经脱离了主线程
2. 并行处理任务，使得可以多个请求同时得到服务
3. 任务处理代码必须是线程安全的，因为有多个任务会并发地调用它。 



## 4. 无限制创建线程的缺点

显式的为任务创建线程实例中，为每个任务都创建一个线程，存在一些实际的缺陷：

* **线程生命周期的开销。**创建和关闭线程都需要借助操作系统，花费大量时间。
* **资源消耗高。**如果可运行的线程数超过可用的处理器数，线程将会空闲。大量空闲线程会占用更多的内存。
* **稳定性问题。**应该限制可创建线程的数目。

通常来说，在一定范围增加创建线程，可以提高系统的吞吐量，一旦超出范围，创建更多线程可能占用过多资源，导致程序出现各种问题。