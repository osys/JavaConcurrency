## 1. 饥饿(starvation)

* 当线程访问它需要的资源时却被永久拒绝，将会发生饥饿。
* 线程 API 定义了 10 个优先级级别， 并对应到操作系统相应的调度优先级中。
* 线程 API 定义的线程优先级仅仅作为调度的参考。
* 有一些操作系统优先级别本身就少于10个，那么其中多个 Java 的优先级会映射到操作系统相同的优先级。

> 抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。



## 2. 弱响应性

* 如果在 GUI 应用程序中，使用了后台线程，那么较大可能会引起响应性差。
* GUI框架中，如果后台任务是cpu密集型的，那么它会与主的GUI事件线程竞争 cpu 的时钟周期，可能导致 cpu 主线程的响应性弱。这时我们可以降低后台线程的优先级。

不良的锁管理也可能导致糟糕的响应性。如果某个线程长时间占有一个锁（或者正在对一个大容器进行迭代，并且对每个元素进行计算密集的处理），而其他想要访问这个容器的线程就必须等待很长时间。



## 3. 活锁(livelock)

活锁是线程活跃度失败的另一种形式，尽管没有阻塞，线程仍不能继续进行，因为它不断尝试相同的操作，却总是失败。

如：

* 在消息处理应用程序中，如果消息处理失败，其中传递消息的底层架构会会退整个事物，并把它置回队首。
* 如果消息处理程序对某种特定类型的消息处理存在bug，每次处理都会失败，那么每一次这个消息都会被从队列中取出，传递到存在问题的处理器(handler)，然后发生事务回退。
* 因为这条消息又会回到队首，处理器会不断被这样重复调用，并返回重复结果。这就是通常称为毒药信息 (poison message）的问题。

> 如何避免：在重试机制中引入随机性。

如：

* 两台机器尝试使用相同的频率，来发送数据包，那么这些数据包就会发生冲突。并又双双重试。
* 如果它们都非常精确地在一秒后重试，它们又会发生冲突，并不断冲突下去，导致数据包永远不能发送。
* 为了避免这种情况发生，我们可以通过用使一个随机组件它们进行等待。
* 在并发程序中，通过随机等待和撇回来进行重试能够相当有效地避免活锁的发生。

