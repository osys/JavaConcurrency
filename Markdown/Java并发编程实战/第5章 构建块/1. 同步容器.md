## 1. 同步容器

* 在Java的集合容器框架中，主要有四大类别：List、Set、Queue、Map。

* 其中List、Set、Queue接口分别继承了`Collection`接口，`Map`本身是一个接口。

* 同步容器主要包括2类

    1. Vector、Stack

        ```
        Vector实现了List接口，Vector实际上就是一个数组，和ArrayList类似，但是它进行了同步措施。
        Stack也是一个同步容器，它的方法也用synchronized进行了同步，它实际上是继承于Vector类。
        ```

    2. HashTable

        ```
        HashTable实现了Map接口，它和HashMap很相似，但是HashTable进行了同步处理，而HashMap没有。
        ```

        



## 2. 同步容器中出现的问题

同步容器都是线程安全的。但是对于复合操作，可能需要使用额外的客户端加锁进行保护。

通常对容器的复合操作包括：

* 迭代
* 导航(根据一定的顺序寻找下一个元素)
* 条件运算(缺少即加入......)



操作 Vector 的复合操作可能导致混乱结果：

```java
import java.util.Vector;

/**
 * Created by osys on 2022/08/28 21:48.
 */
public class UnsafeVectorHelpers {
    public static Object getLast(Vector list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }

    public static void deleteLast(Vector list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
}
```

对于 `list.get()`、`list.remove()`和`list.size()` 其本身是线程安全的：

```java
/**
 * 返回此 Vector 中指定位置的元素。
 *
 * @param index 要返回的元素的索引
 * @return 指定索引处的对象
 * @throws ArrayIndexOutOfBoundsException 如果索引超出范围
 * ({@code index < 0 || index >= size()})
 * @从 1.2 开始
 */
public synchronized E get(int index) {
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}

/**
 * 移除此 Vector 中指定位置的元素。
 * 将任何后续元素向左移动（从它们的元素中减去一个
 * 指数）。返回从 Vector 中删除的元素。
 *
 * @throws ArrayIndexOutOfBoundsException 如果索引超出范围
 * ({@code index < 0 || index >= size()})
 * @param index 要删除的元素的索引
 * @return 被移除的元素
 * @从 1.2 开始
 */
public synchronized E remove(int index) {
    modCount++;
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);
    E oldValue = elementData(index);

    int numMoved = elementCount - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                numMoved);
    elementData[--elementCount] = null; // Let gc do its work

    return oldValue;
}

/**
 * 返回此向量中的组件数。
 *
 * @return 此向量中的组件数
 */
public synchronized int size() {
    return elementCount;
}
```

但是对于 `getLast()` 和 `deleteLast()` 则不然。

```
1. 假如两个线程分别调用 getLast() 和 deleteLast() 方法

2. 它们先后获取到的 lastIndex 都是 10

3. 调用 deleteLast() 的线程先按照 lastIndex=10 删除了 Vector 的最后一个元素

4. 另一个调用 getLast() 的线程此时按照 lastIndex=10 获取 Vector 的一个元素(元素已经被删除了)

5. 抛出异常：ArrayIndexOutOfBoundsException(index)
```



使用客户端加锁，对 Vector 进行复合操作：

```java
import java.util.Vector;

/**
 * Created by osys on 2022/08/28 21:48.
 */
public class SafeVectorHelpers {

    private final Vector list;

    public SafeVectorHelpers(Vector list) {
        this.list = list;
    }

    public Object getLast() {
        synchronized (list) {
            int lastIndex = list.size() - 1;
            return list.get(lastIndex);
        }
    }

    public void deleteLast() {
        synchronized (list) {
            int lastIndex = list.size() - 1;
            list.remove(lastIndex);
        }
    }
}
```



迭代中可能抛出 `ArrayIndexOutOfBoundsException`：

```java
for (int i=0; i<vector.size(); i++) {
    doSomething(vector.get(i));
}
```

某个线程在操作 `vector` 的同时，并不能阻止别的线程对其进行操作，假如在迭代的过程中，其它线程操作删除了 `vector` 里面的一个元素，那么就会抛出 `ArrayIndexOutOfBoundsException` 

使用客户端加锁进行迭代：

```java
synchronized (vector) {
    for (int i=0; i<vector.size(); i++) {
        doSomething(vector.get(i));
    }
}
```

**这样会削弱并发性。在迭代的时候，其它线程并不能访问 `vector`**



## 3. 迭代器和 ConcurrentModificationException

对 Collection 进行迭代的标准方式是使用 Iterator。在迭代过程中，对 `Collection` 进行了修改操作，会导致抛出 `ConcurrentModificationException` 异常。

```java
List<Object> widgetList = Collections.synchronizedList(new ArrayList<>());
// 可能地出 ConcurrentModificationException
for (Object obj : widgetList) {
    doSomething(obj);
}
```

* 上面说到 **客户端加锁进行迭代** 会影响并发性能。
* 在迭代期间，对容器加锁的一个替代办法是`复制容器`。
* 因为复制是线程限制的，没有其他的线程能够在迭代期间对其进行修改，这样消除了`ConcurrentModificationException` 发生的可能性。（**`容器仍然需要在复制期间对自己加锁`**）。
* 复制容器会有明显的性能开销：这样做是好是坏取决于许多因素，包括容器的大小、每一个元素的工作量、迭代操作相对于容器其他操作的频率，以及响应性和吞吐量的
    需求。



## 4. 隐藏迭代器

`迭代器加锁`和`复制容器`可以防止迭代器抛出ConcurrentModificationException异常。所有对共享容器进行迭代的地方都需要此操作。

在某些情况下，迭代器是隐藏起来的。如：

```java
import java.util.HashSet;
import java.util.Random;
import java.util.Set;

/**
 * Created by osys on 2022/08/28 21:48.
 */
public class HiddenIterator {
 
	private final Set<Integer> set = new HashSet<>();
	
	public synchronized void add(Integer i) {
		set.add(i);
	}
	
	public synchronized void remove(Integer i) {
		set.remove(i);
	}
	
	public void addTenThings() {
		Random random = new Random();
		for (int i=0; i < 10 ; i++) {
			add(random.nextInt());
		}
		System.out.println("DEBUG: 添加了十个元素 " + set);
	}
}
```

在如下代码中将执行迭代操作：

```java
System.out.println("DEBUG: 添加了十个元素 " + set);
```

编译器将字符串的连接操作转换为`StringBuilder.append(Object)`，而这个方法又会调用**容器**的`AbstractCollection.toString()`方法：

```java
/**
 * 返回此集合的字符串表示形式。字符串
 * 表示由集合中的元素列表组成
 * 它们由其迭代器返回的顺序，括在方括号中
 * (<tt>"[]"</tt>)。相邻元素由字符分隔
 * <tt>"、"</tt>（逗号和空格）。元素被转换为字符串
 * 通过 {@link String#valueOf(Object)}。
 *
 * @return 此集合的字符串表示形式
 */
public String toString() {
    Iterator<E> it = iterator();
    if (! it.hasNext())
        return "[]";

    StringBuilder sb = new StringBuilder();
    sb.append('[');
    for (;;) {
        E e = it.next();
        sb.append(e == this ? "(this Collection)" : e);
        if (! it.hasNext())
            return sb.append(']').toString();
        sb.append(',').append(' ');
    }
}
```

`addTenThings()`方法可能会抛出`ConcurrentModificationException`，因为在生成调试消息的过程中，`AbstractCollection.toString()`对容器进行迭代。

