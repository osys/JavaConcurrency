## 1. 垃圾回收

* 垃圾回收的时序是不可预知的，在一个测量数据的测试运行中，任何时候垃圾回收器都有可能运行。

* 多次对程序进行测试时，如果仅在某一两次触发了垃圾回收，这可能会导致最终测试结果有所偏差。

* 有两种策略可以防止垃圾回收操作对测试结果产生偏差。

    * 第一种策略是，确保垃圾回收操作在测试运行的整个期间都不会执行。

    * 第二种策略是，确保垃圾回收操作在测试期间执行多次，这样测试程序就能充分反映出运行期间的内存分配与垃圾回收等开销。

        （可以在调用JVM时指定-verbose：gc来判断是否执行了垃圾回收操作）



## 2. 动态编译

* HotSpot JVM 结合了字节码解释和动态编译。
* 当一个类首次被加载后，JVM 会以解释字节码的方式执行。
* 如果一个方法运行得较为频繁，动态编译器最终会将其挑出来，转成本机代码，当编译完成后，执行方式将由解释执行转换到直接执行。
* 编译的时机时不可预知的。大多数程序在运行得足够长后，所有频繁执行的代码露肩都会被编译。
* 在进行性能测试时，可以长时间运行要测试的程序，这样编译过程和解释执行仅仅占总体运行的很小一部分，对结果影响较小。或者先让待测试代码频繁执行，这样代码就会被完全编译，再测试时，即为直接执行。

在运行程序时，使用 `-XX: +PrintCompilation`，程序会在动态编译时打印出信息。可以通过这条消息来验证动态编译是在测试运行前，而不是在运行过程中。



## 3. 不切实际的竞争程度

* 并发的应用程序总是交替执行两种非常不同的工作：
    1. 访问共享数据，比如从共享工作队列中获取下一个任务。
    2. 线程本地的计算（执行任务，假设任务自身并不访问共享数据）。
* 依赖于两种工作类型的相关特性，应用程序会经历不同级别的竞争，并表现出不同的性能与伸缩性行为。



如果有N个线程从共享工作队列中获取任务并执行，这些任务都是计算密集型的、耗时的（但并未频繁地跨线程访问数据），这种情况几乎没有竟争；吞吐量只受限于可用的 CPU 资源。另一方面，如果任务的生命周期很短，在工作队列上就会存在大量竞争，此时吞吐量受限于同步的开销。

为了获得有实际意义的结果，并发性能测试，除了需要考虑协调并发的因素，应该尽最去模拟让线程本地的计算由某一个特有的应用程序来完成。如果每个任务在真实应用程序中完成的工作，与测试程序相比，其本质和范围有相当大的不同，那么得到的关于性能瓶颈位置的结论将是毫无根据的。



