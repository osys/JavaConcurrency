* 性能可伸缩性: 多线程能充分的发挥出闲置的处理能力，使现有任务正在运行的情况下立刻开始着手处理新的任务，提高系统的响应性。

* Amdahl 定律: 

    N 表示处理器数量，F表示串行化任务的比重。
    $$
    Speedup \leq 1 \div [F + \big(1 - F\big)\div N ]
    $$
    

* 操作系统会为每个就绪的任务分配一个特定的时间在CPU中运行，使用完时间片后由一个 **时间计数器** 发出时钟中断请求，停止任务。停止前一个任务后，操作系统会从就绪队列队首中取出一个新的任务，分配执行时间，到该CPU中运行任务。

* 在 CPU 上对进程或者线程进行切换，切换过程中的信息被保存在进程控制块。当一个新的线程被切换进CPU时，它所需要的数据可能不在当前CPU的本地缓存中，因此上下文切换可能导致一些缓存缺失，因而线程在首次调度运行时会更加缓慢。

*  `锁的粗化(lock coarsening)`，把邻近的同步代码块用相同的锁合并起来。

* 成熟的 JVM 可以使用 `逸出分析(escape analysis)` 来识别本地对象的引用(即找出不会被发布到堆的本地对象引用)

* `串行化` 会损害可伸缩性，`上下文切换` 会损害性能。

* 可以通过`分拆锁(lock spliting)`和`分离锁(lock striping)`来减小锁的粒度。

* `ReadWriteLock` 实行了一个 **多读者-单写者**(multiple-reader, single-write)加锁规则：只要没有更改，那么多个读者可以并发访问共享资源，但是写者必须独占获得锁。





程序的可伸缩性是由必须连续执行的代码比例决定的。提升可伸缩性：减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占锁或非阻塞锁来取代独占锁。

