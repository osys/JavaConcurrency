## 1. 性能测试

* 性能测试要符合当前程序的应用场景，理想情况下应该反映出被测试对象在应用程序中的实际用法。
* 性能测试将衡量典型测试用例中的端到端功能。通常，要获得一组合理的使用场景并不容易，理想情况下，在测试中应该反映出被测试对象在应用程序中的实际用法。
* 根据经验值来调整各种不同的限值，例如线程数量，缓存容量等等，这些限值都依赖于平台特性(如CPU、内存)。



## 2. 比较多种算法

* 测试结果表明，LinkedBlockgingQueue 的可伸缩性要高于 ArrayBlockingQueue。
* 从测试结果来看，这个结果似乎有些奇怪，链表队列在每次插入元素时，都必须分配一个链表节点对象，这似乎比基于数组的队列相比，链表队列的 put 和 take 等方法支持并发性更高的访问，因为一些优化后的链接队列算法能将队列头节点的更新操作与尾节点的更新操作分享开来。
* 因此如果算法能通过多执行一些内存分配操作来降低竞争程度，那么这种算法通常具有更高的可伸缩性。



## 3. 测量响应性

* 同一进程可以同时在多个内核上执行(多线程)，并且可以在进程之间共享内存。因此无论上下文切换发生什么，缓存同步都是不可避免的。
* 如果缓存过小，那么将导致非常多的上下文切换次数。频繁的上下文切换，会导致程序吞吐量较为糟糕。
* 如果线程由于较多的同步条件限制，导致持续的被阻塞，不公平的信号量(`Semaphore`)能够提供更好的吞吐量(差异性大)，公平的信号量提供更低的差异性。

