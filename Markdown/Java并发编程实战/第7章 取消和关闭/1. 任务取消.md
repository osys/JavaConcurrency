> 任务取消

外部代码，能够将某个操作正常完成之前，将其置入完成状态，那么这个操作就称为**可取消的（Cancellable）**。

取消操作的原因有很多：

1. 用户请求取消。
2. 有时间限制的操作，如超时设定。
3. 应用程序事件。
4. 错误。
5. 关闭。



> 示例：使用 volatile 域，保存取消状态

```java
import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * 生成素数
 * @author osys
 */
@ThreadSafe
public class PrimeGenerator implements Runnable {
    private static ExecutorService exec = Executors.newCachedThreadPool();

    @GuardedBy("this")
    private final List<BigInteger> primes = new ArrayList<>();

    private volatile boolean cancelled;

    @Override
    public void run() {
        BigInteger prime = BigInteger.ONE;
        while (!cancelled) {
            // 返回大于此 prime 且可能是素数的第一个整数
            prime = prime.nextProbablePrime();
            synchronized (this) {
                primes.add(prime);
            }
        }
    }

    public void cancel() {
        cancelled = true;
    }

    public synchronized List<BigInteger> get() {
        return new ArrayList<BigInteger>(primes);
    }

    /**
     * 生成【素数】的程序运行一秒钟
     * @return 素数
     */
    static List<BigInteger> aSecondOfPrimes() throws InterruptedException {
        PrimeGenerator generator = new PrimeGenerator();
        exec.execute(generator);
        try {
            // 主线程sleep1秒
            SECONDS.sleep(1);
        } finally {
            // 暂停生成素数的线程
            generator.cancel();
        }
        return generator.get();
    }
}
```

Primecenerator 使用了简单的取消策略：客户端代码通过调用 cancel 请求取消，Primecenerator 每次搜索素数前检查是否有取消请求，当发现取消请求时就退出。



> 中断

* `线程中断` 是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在某些情况下停止当前工作，并转而执行其他的工作。
* 每个线程都有一个 boolean 类型的中断状态。当中断线程时，这个线程的中断状态将被设置为 true。



线程的中断方法：

```java
public class Thread {
    /** 中断这个线程 */
    public void interrupt() { ... }
    /** 获取此线程是否已被中断。线程的中断状态不受此方法的影响。 */
    public boolean isInterrupted() { ... }
    /** 获取当前线程是否被中断。通过该方法清除线程的中断状态。换句话说，如果这个方法被连续调用两次，第二次调用将返回 false */
    public static boolean interrupted(){ ... }
    ......
}
```

**调用 interrupt 并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。**

中断操作，并不会真正的中断一个正在运行的线程，只是发出了中断请求，线程会在一个合适的时刻中断自己。



> 中断策略

* `中断策略` 规定线程如何解释某个 `中断请求`

* 取消操作：`中断策略` 规定 **`线程级取消`操作** 或者 **`服务级取消`操作** 

    ```
    1. 尽快退出，必要时进行清理
    2. 通知线程所有者，该线程已经退出
    ```

* 此外还可以建立其他的中断策略，如 `暂停` 服务、`重新开始` 服务。



> 响应中断

在调用可中断的阻塞函数时，有两种实用策略可以处理 `InterruptedException` 中断异常:

* `传递异常`，使方法成为可中断的阻塞方法。如：

    ```java
    public interface BlockingQueue<E> extends Queue<E> {
        // 将指定元素插入此队列。队列满了，则等待有位置再插入
        void put(E e) throws InterruptedException;
    }
    
    public class Thread implements Runnable {
        // 使当前执行的线程在指定的毫秒数内休眠
        public static native void sleep(long millis) throws InterruptedException;
    }
    
    // BlockingQueue.put() 方法和 Thread.sleep() 方法，都传递了异常 ---- InterruptedException
    // 如果任何线程中断了当前线程。抛出此异常时清除当前线程的中断状态
    ```

    

* `保存中断状态`，上层调用栈中的代码，能够对线程的中断状态进行处理。如：

    ```java
    public class Thread implements Runnable {
        // 中断线程，只是将线程状态标记为中断状态，但不会终止线程，线程还会继续执行
        public void interrupt() {
            // ...
        }
    
        // 测试当前线程是否被中断。通过该方法清除线程的中断状态。
        public static boolean interrupted() {
            return currentThread().isInterrupted(true);
        }
    
        // 测试某个线程是否已被中断。根据传递的 ClearInterrupted 的值，是否重置中断状态。
        private native boolean isInterrupted(boolean ClearInterrupted);
    }
    ```

    

> 示例：计时运行

```java
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * 外部线程中，安排中断
 * @author osys
 */
public class TimedRun {
    private static final ExecutorService taskExec = Executors.newCachedThreadPool();

    public static void timedRun(Runnable runnable,
                                long timeout,
                                TimeUnit unit) throws InterruptedException {
        Future<?> task = taskExec.submit(runnable);
        try {
            task.get(timeout, unit);
        } catch (TimeoutException e) {
            // 任务将被取消
        } catch (ExecutionException e) {
            // 任务中抛出异常
            throw LaunderThrowable.launderThrowable(e.getCause());
        } finally {
            // 如果任务已经完成，则不做处理
            // 如果任务未完成，任务将被取消
            task.cancel(true);
        }
    }
}
```

