> 任务取消

外部代码，能够将某个操作正常完成之前，将其置入完成状态，那么这个操作就称为**可取消的（Cancellable）**。

取消操作的原因有很多：

1. 用户请求取消。
2. 有时间限制的操作，如超时设定。
3. 应用程序事件。
4. 错误。
5. 关闭。



> 示例：使用 volatile 域，保存取消状态

```java
import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * 生成素数
 * @author osys
 */
@ThreadSafe
public class PrimeGenerator implements Runnable {
    private static ExecutorService exec = Executors.newCachedThreadPool();

    @GuardedBy("this")
    private final List<BigInteger> primes = new ArrayList<>();

    private volatile boolean cancelled;

    @Override
    public void run() {
        BigInteger prime = BigInteger.ONE;
        while (!cancelled) {
            // 返回大于此 prime 且可能是素数的第一个整数
            prime = prime.nextProbablePrime();
            synchronized (this) {
                primes.add(prime);
            }
        }
    }

    public void cancel() {
        cancelled = true;
    }

    public synchronized List<BigInteger> get() {
        return new ArrayList<BigInteger>(primes);
    }

    /**
     * 生成【素数】的程序运行一秒钟
     * @return 素数
     */
    static List<BigInteger> aSecondOfPrimes() throws InterruptedException {
        PrimeGenerator generator = new PrimeGenerator();
        exec.execute(generator);
        try {
            // 主线程sleep1秒
            SECONDS.sleep(1);
        } finally {
            // 暂停生成素数的线程
            generator.cancel();
        }
        return generator.get();
    }
}
```

Primecenerator 使用了简单的取消策略：客户端代码通过调用 cancel 请求取消，Primecenerator 每次搜索素数前检查是否有取消请求，当发现取消请求时就退出。



> 中断

* `线程中断` 是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在某些情况下停止当前工作，并转而执行其他的工作。
* 每个线程都有一个 boolean 类型的中断状态。当中断线程时，这个线程的中断状态将被设置为 true。



线程的中断方法：

```java
public class Thread {
    /** 中断这个线程 */
    public void interrupt() { ... }
    /** 获取此线程是否已被中断。线程的中断状态不受此方法的影响。 */
    public boolean isInterrupted() { ... }
    /** 获取当前线程是否被中断。通过该方法清除线程的中断状态。换句话说，如果这个方法被连续调用两次，第二次调用将返回 false */
    public static boolean interrupted(){ ... }
    ......
}
```

**调用 interrupt 并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。**

中断操作，并不会真正的中断一个正在运行的线程，只是发出了中断请求，线程会在一个合适的时刻中断自己。



> 示例：通过中断进行取消

```java
import java.math.BigInteger;
import java.util.concurrent.BlockingQueue;

/**
 * @author osys
 */
public class BrokenPrimeProducer extends Thread {

    private final BlockingQueue<BigInteger> queue;

    private volatile boolean cancelled = false;

    BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            BigInteger prime = BigInteger.ONE;
            while (!cancelled) {
                // 返回大于此 prime 且可能是素数的第一个整数
                prime = prime.nextProbablePrime();
                queue.put(prime);
            }
        } catch (InterruptedException ignored) { }
    }

    public void cancel() {
        cancelled = true;
    }
}
```



> 中断策略