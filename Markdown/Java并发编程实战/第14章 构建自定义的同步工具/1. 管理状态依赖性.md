## 1. 管理状态依赖性

* 状态依赖性指某种操作必须依赖于指定的状态才可以执行。比如一个阻塞队列的`take`方法依赖于这个阻塞队列中有至少一个元素这个状态。
* 如果一个状态依赖性操作所依赖的状态不满足，通常有几种处理办法：
    1. 抛出异常
    2. 使用某种约定的错误返回值
    3. 阻塞，直到依赖的状态被满足

> 状态依赖的可阻塞行为结构

```java
void blockingAction() throws InterruptedException {
    // ...
    // 请求 依赖的状态 锁
    // ...
    
    // 依赖条件不成立
    while (不成立的条件) {
        // 释放锁
        
        // ...
        // 直到依赖条件成立。如果中断或超时过期，则可选失败
        // ... 
        
        // 请求锁
    }
    
    // do something
    // 释放锁
}
```

生产者-消费者的设计经常会使用 ArrayBlockingQueue 这种有限缓存。一个有限缓存提供的 put 和 take 操作，每一个都有先验条件：不能从空缓存中获取元素，也不能把元素置入已满的緩存中。如果依赖于状态的操作在处理先验条件时失败，可以抛出异常或者返回错误状态（把问题留给调用者)，也可以保持阻塞直到对象转入正确的状态。



> 示例：有限缓存的实现

```java
import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

@ThreadSafe
public abstract class BaseBoundedBuffer<V> {

    @GuardedBy("this")
    private final V[] buf;

    @GuardedBy("this")
    private int tail;

    @GuardedBy("this")
    private int head;

    @GuardedBy("this")
    private int count;

    protected BaseBoundedBuffer(int capacity) {
        this.buf = (V[]) new Object[capacity];
    }

    protected synchronized final void doPut(V v) {
        buf[tail] = v;
        if (++tail == buf.length) {
            tail = 0;
        }
        ++count;
    }

    protected synchronized final V doTake() {
        V v = buf[head];
        buf[head] = null;
        if (++head == buf.length) {
            head = 0;
        }
        --count;
        return v;
    }

    public synchronized final boolean isFull() {
        return count == buf.length;
    }

    public synchronized final boolean isEmpty() {
        return count == 0;
    }
}
```



## 2. 将先验条件失败传给调用者

> 如果有缓存不满足先验条件，会停滞不前

```java
import net.jcip.annotations.ThreadSafe;

@ThreadSafe
public class GrumpyBoundedBuffer <V> extends BaseBoundedBuffer<V> {
    
    public GrumpyBoundedBuffer() {
        this(100);
    }

    public GrumpyBoundedBuffer(int size) {
        super(size);
    }

    public synchronized void put(V v) throws BufferFullException {
        if (isFull()) {
            throw new BufferFullException();
        }
        doPut(v);
    }

    public synchronized V take() throws BufferEmptyException {
        if (isEmpty()) {
            throw new BufferEmptyException();
        }
        return doTake();
    }
}

class BufferFullException extends RuntimeException {
}

class BufferEmptyException extends RuntimeException {
}
```

如果向 GrumpyBoundedBuffer 中添加、拿取元素，GrumpyBoundedBuffer 已经满了、没有元素，那么将抛出 RuntimeException。



> 调用 GrumpyBoundedBuffer

```java
public class GrumpyBoundedBufferDemo {
    private GrumpyBoundedBuffer<String> buffer;
    int SLEEP_GRANULARITY = 50;

    public void useBuffer() throws InterruptedException {
        while (true) {
            try {
                String item = buffer.take();
                // ... ...
                break;
            } catch (BufferEmptyException e) {
                Thread.sleep(SLEEP_GRANULARITY);
                // 建议使用：Thread.yield() 向调度程序提示当前线程愿意放弃其当前对处理器的使用。而不占用CPU
            }
        }
    }
}
```

如果 GrumpyBoundedBuffer 中没有元素，那么 sleep，循环等待有元素可用。



## 3. 利用 “轮询加休眠” 实现拙劣的阻塞

> 有限缓存使用了拙劣的阻塞

```java
import net.jcip.annotations.ThreadSafe;

@ThreadSafe
public class SleepyBoundedBuffer <V> extends BaseBoundedBuffer<V> {
    int SLEEP_GRANULARITY = 60;

    public SleepyBoundedBuffer() {
        this(100);
    }

    public SleepyBoundedBuffer(int size) {
        super(size);
    }

    public void put(V v) throws InterruptedException {
        while (true) {
            synchronized (this) {
                if (!isFull()) {
                    doPut(v);
                    return;
                }
            }
            Thread.sleep(SLEEP_GRANULARITY);
        }
    }

    public V take() throws InterruptedException {
        while (true) {
            synchronized (this) {
                if (!isEmpty()) {
                    return doTake();
                }
            }
            Thread.sleep(SLEEP_GRANULARITY);
        }
    }
}
```

SleepyBoundedBuffer 与 GrumpyBoundedBuffer 不同的是，在 put 和 take 操作时，使用轮询+休眠的方式，直到满足条件。

像大多数行为良好的阻塞库的方法一样，SleepyBoundedBuffer 通过中断支持取消，如果被中断，它会提前返回，并抛出 InterruptedException。



## 4. 使用条件队列解决拙劣的阻塞

条件队列可以让一组线程(等特集)，以某种方式等待相关条件变成真。不同于传统的队列，它们的元素是数据项：条件队列的元素是等待相关条件的线程。

> 有限缓存使用条件队列

```java
import net.jcip.annotations.ThreadSafe;

@ThreadSafe
public class BoundedBuffer<V> extends BaseBoundedBuffer<V> {
    public BoundedBuffer() {
        this(100);
    }

    public BoundedBuffer(int size) {
        super(size);
    }

    public synchronized void put(V v) throws InterruptedException {
        while (isFull()) {
            wait();
        }
        doPut(v);
        notifyAll();
    }

    public synchronized V take() throws InterruptedException {
        while (isEmpty()) {
            wait();
        }
        V v = doTake();
        notifyAll();
        return v;
    }

    public synchronized void alternatePut(V v) throws InterruptedException {
        while (isFull()) {
            wait();
        }
        boolean wasEmpty = isEmpty();
        doPut(v);
        if (wasEmpty) {
            notifyAll();
        }
    }
}
```

使用了超类 Object 中的 wait()、notify()、notifyAll()方法：

```java
// 使当前线程等待，直到另一个线程为此对象调用notify()方法或notifyAll()方法。
public final void wait() throws InterruptedException { }

// 唤醒正在此对象的监视器上等待的单个线程。
public final native void notify();

// 唤醒正在此对象的监视器上等待的所有线程。
public final native void notifyAll();
```

