## 1. 向已有的线程安全类添加功能

* Java 类库中包含了很多有用的 `构建块` 类。`重用`这些已有的类要好于创建一个新的。重用能够降低开发的难度、风和维护成本。

* 有时一个线程安全类支持我们需要的全部操作，但更多时候，一个类只支持我们需要的大部分操作，这时我们需要在不破坏其线程安全性的前提下，向它添加一个新的操作。

* 修改原始的类

    1. 添加一个新原子操作的最安全的方式是，`修改原始的类`，以支持期望的操作。
    2. 但是你可能无法访问源代码或者没有修改的自由，所以这通常是不可能的。
    3. 即使你可以修改原始的类，也需要理解其实现的同步策略，才能在维持原有设计的前提下完善它的功能。
    4. 直接向类中加入新方法，意味着所有实现类同步策略的代码仍然包含在一个源代码文件中，因此便于理解与维护。

* 扩展这个类

    1. 另一种方法是`扩展这个类`，假如这个类在设计上是可以扩展的。如：

        ```java
        import net.jcip.annotations.ThreadSafe;
        
        import java.util.Vector;
        
        /**
         * @author osys
         */
        @ThreadSafe
        public class BetterVector <E> extends Vector<E> {
            /** 扩展可序列化类时，应重新定义 serialVersionUID */
            static final long serialVersionUID = -3963416950630760754L;
        
            public synchronized boolean putIfAbsent(E x) {
                boolean absent = !contains(x);
                if (absent) {
                    add(x);
                }
                return absent;
            }
        }
        ```

        

    2. 扩展后，同步策略的实现会被分布到多个独立维护的源代码(`.class`)文件中，所以扩展一个类比直接在类中加入代码更脆弱。

    3. 如果低层的类选择了不同的锁保护它的状态变量，从而会改变它的同步策略，子类就在不知不觉中被破坏，因为它不能再用`正确的锁控制`对基类状态的并发访问。



## 2. 客户端加锁

创建一个助手类，该助手类包含一个作用于线程安全 List 的原子 `缺少即加入` 的操作。



1. 非线程安全的 “缺少即加入” 实现（不要这样做）

    ```java
    @NotThreadSafe
    class BadListHelper <E> {
        public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    
        public synchronized boolean putIfAbsent(E x) {
            boolean absent = !list.contains(x);
            if (absent) {
                list.add(x);
            }
            return absent;
        }
        
        // =========================
        // 等等有关操作 list 的其它方法
        // =========================
    }
    ```

    这里是并不能保证对 `list` 的操作是线程安全的，即使使用了同步修饰 `putIfAbsent()` 方法。

    虽然对 `putIfAbsent()` 加了内置锁，但是这仅仅限制同一时间仅有单一线程调用此方法。

    我们并不能保证其它线程调用 `BadListHelper` 的其它方法，对 `list` 进行操作。即使其它方法也都是用了内置锁。

    

2. 使用客户端加锁实现的 “缺少即加入”

    ```java
    @ThreadSafe
    class GoodListHelper <E> {
        public List<E> list = Collections.synchronizedList(new ArrayList<E>());
    
        public boolean putIfAbsent(E x) {
            synchronized (list) {
                boolean absent = !list.contains(x);
                if (absent) {
                    list.add(x);
                }
                return absent;
            }
        }
    
        // =========================
        // 等等有关操作 list 的其它方法
        // =========================
    }
    ```

    线程安全



* 如果说，为了添加另一个原子操作而去扩展一个类(扩展类加锁)容易出问题，是因为它将加锁的代码分布到了继承体系中的多个类里。
* 然而客户端加锁其实是更加脆弱的，因为它必须将`类 a.class`中的加锁代码置入与`a.class`完全无关的类中。
* 在那些`不关注锁策略`的类中使用客户端加锁时，一定要小心。客户端加锁与扩展类有很多共同之处：所得类的行为与基类的实现之间都存在耦合。正如同扩展会破坏实现的封装性一样，客户端加锁会破坏同步策略的封装性。



## 3. 组合(composition)

向己有的类中添加一个原子操作，还有更好的选择：组合。

```java
import net.jcip.annotations.ThreadSafe;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

/**
 * @author osys
 */
@ThreadSafe
public class ImprovedList<T> implements List<T> {
    private final List<T> list;

    /**
     * PRE: list 参数是线程安全的。
     */
    public ImprovedList(List<T> list) {this.list = list;}

    public synchronized boolean putIfAbsent(T x) {
        boolean contains = list.contains(x);
        if (contains) {
            list.add(x);
        }
        return !contains;
    }

    // List 方法的普通委托。
    // 可变方法必须同步以确保 putIfAbsent 的原子性。
    @Override
    public synchronized void clear() {list.clear();}
    @Override
    public synchronized void add(int index, T element) {list.add(index, element);}
    @Override
    public synchronized boolean add(T e) {return list.add(e);}
    @Override
    public synchronized boolean remove(Object o) {return list.remove(o);}
    @Override
    public synchronized boolean addAll(Collection<? extends T> c) {return list.addAll(c);}
    @Override
    public synchronized boolean addAll(int index, Collection<? extends T> c) {return list.addAll(index, c);}
    @Override
    public synchronized boolean removeAll(Collection<?> c) {return list.removeAll(c);}
    @Override
    public synchronized boolean retainAll(Collection<?> c) {return list.retainAll(c);}
    @Override
    public synchronized T set(int index, T element) {return list.set(index, element);}
    @Override
    public synchronized T remove(int index) {return list.remove(index);}

    // 不可变方法
    @Override
    public  T get(int index) {return list.get(index);}
    @Override
    public int size() {return list.size();}
    @Override
    public boolean isEmpty() {return list.isEmpty();}
    @Override
    public boolean contains(Object o) {return list.contains(o);}
    @Override
    public Iterator<T> iterator() {return list.iterator();}
    @Override
    public Object[] toArray() {return list.toArray();}
    @Override
    public <T> T[] toArray(T[] a) {return list.toArray(a);}
    @Override
    public boolean containsAll(Collection<?> c) {return list.containsAll(c);}
    @Override
    public boolean equals(Object o) {return list.equals(o);}
    @Override
    public int hashCode() {return list.hashCode();}
    @Override
    public int indexOf(Object o) {return list.indexOf(o);}
    @Override
    public int lastIndexOf(Object o) {return list.lastIndexOf(o);}
    @Override
    public ListIterator<T> listIterator() {return list.listIterator();}
    @Override
    public ListIterator<T> listIterator(int index) {return list.listIterator(index);}
    @Override
    public List<T> subList(int fromIndex, int toIndex) {return list.subList(fromIndex, toIndex);}
}
```

* ImprovedList 通过将操作委托给底层的 List 实例，实现了 List 的操作，同时还添加了一个原子的`putIfAbsent()`方法。
* 就像 `Collections.synchronizedList` 和其他容器封装器那样，ImprovedList 假设一旦有一个 list 传给它的构造函数后，客户将不再直接使用这个 list，而仅仅通过 ImprovedList 访问它。
* 通过使用内部锁，ImproveaList 引入了一个`新的锁层`。
* 它并不关心底层的 List 是否线程安全，即使 List 不是线程安全的，或者会改变 ImproveaList 的锁实现，Improvedtist 都有自己兼容的锁可以提供线程安全性。
* 虽然额外的一层同步可能会带来一些微弱的性能损失，但是相比于去尝试模拟另一个对象的锁策路而言，ImprovedList并不那么脆弱。
* 我们己经使用 Java 监视器模式有效地封裝了一个己有的 List，而且只要我们的类持有底层 List 的`唯一外部引用`，那么就能保证提供线程安全性。