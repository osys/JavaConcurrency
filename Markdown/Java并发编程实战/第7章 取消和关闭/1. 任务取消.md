## 1. 任务取消

外部代码，能够将某个操作正常完成之前，将其置入完成状态，那么这个操作就称为**可取消的（Cancellable）**。

取消操作的原因有很多：

1. 用户请求取消。
2. 有时间限制的操作，如超时设定。
3. 应用程序事件。
4. 错误。
5. 关闭。



## 2. 示例：使用 volatile 域，保存取消状态

```java
import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * 生成素数
 * @author osys
 */
@ThreadSafe
public class PrimeGenerator implements Runnable {
    private static ExecutorService exec = Executors.newCachedThreadPool();

    @GuardedBy("this")
    private final List<BigInteger> primes = new ArrayList<>();

    private volatile boolean cancelled;

    @Override
    public void run() {
        BigInteger prime = BigInteger.ONE;
        while (!cancelled) {
            // 返回大于此 prime 且可能是素数的第一个整数
            prime = prime.nextProbablePrime();
            synchronized (this) {
                primes.add(prime);
            }
        }
    }

    public void cancel() {
        cancelled = true;
    }

    public synchronized List<BigInteger> get() {
        return new ArrayList<BigInteger>(primes);
    }

    /**
     * 生成【素数】的程序运行一秒钟
     * @return 素数
     */
    static List<BigInteger> aSecondOfPrimes() throws InterruptedException {
        PrimeGenerator generator = new PrimeGenerator();
        exec.execute(generator);
        try {
            // 主线程sleep1秒
            SECONDS.sleep(1);
        } finally {
            // 暂停生成素数的线程
            generator.cancel();
        }
        return generator.get();
    }
}
```

Primecenerator 使用了简单的取消策略：客户端代码通过调用 cancel 请求取消，Primecenerator 每次搜索素数前检查是否有取消请求，当发现取消请求时就退出。



## 3. 中断

* `线程中断` 是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在某些情况下停止当前工作，并转而执行其他的工作。
* 每个线程都有一个 boolean 类型的中断状态。当中断线程时，这个线程的中断状态将被设置为 true。



线程的中断方法：

```java
public class Thread {
    /** 中断这个线程 */
    public void interrupt() { ... }
    /** 获取此线程是否已被中断。线程的中断状态不受此方法的影响。 */
    public boolean isInterrupted() { ... }
    /** 获取当前线程是否被中断。通过该方法清除线程的中断状态。换句话说，如果这个方法被连续调用两次，第二次调用将返回 false */
    public static boolean interrupted(){ ... }
    ......
}
```

**调用 interrupt 并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。**

中断操作，并不会真正的中断一个正在运行的线程，只是发出了中断请求，线程会在一个合适的时刻中断自己。



## 4. 中断策略

* `中断策略` 规定线程如何解释某个 `中断请求`

* 取消操作：`中断策略` 规定 **`线程级取消`操作** 或者 **`服务级取消`操作** 

    ```
    1. 尽快退出，必要时进行清理
    2. 通知线程所有者，该线程已经退出
    ```

* 此外还可以建立其他的中断策略，如 `暂停` 服务、`重新开始` 服务。



## 5. 响应中断

在调用可中断的阻塞函数时，有两种实用策略可以处理 `InterruptedException` 中断异常:

* `传递异常`，使方法成为可中断的阻塞方法。如：

    ```java
    public interface BlockingQueue<E> extends Queue<E> {
        // 将指定元素插入此队列。队列满了，则等待有位置再插入
        void put(E e) throws InterruptedException;
    }
    
    public class Thread implements Runnable {
        // 使当前执行的线程在指定的毫秒数内休眠
        public static native void sleep(long millis) throws InterruptedException;
    }
    
    // BlockingQueue.put() 方法和 Thread.sleep() 方法，都传递了异常 ---- InterruptedException
    // 如果任何线程中断了当前线程。抛出此异常时清除当前线程的中断状态
    ```

    

* `保存中断状态`，上层调用栈中的代码，能够对线程的中断状态进行处理。如：

    ```java
    public class Thread implements Runnable {
        // 中断线程，只是将线程状态标记为中断状态，但不会终止线程，线程还会继续执行
        public void interrupt() {
            // ...
        }
    
        // 测试当前线程是否被中断。通过该方法清除线程的中断状态。
        public static boolean interrupted() {
            return currentThread().isInterrupted(true);
        }
    
        // 测试某个线程是否已被中断。根据传递的 ClearInterrupted 的值，是否重置中断状态。
        private native boolean isInterrupted(boolean ClearInterrupted);
    }
    ```

    

## 6. 示例：计时运行

```java
public class TimeRun {
    private static final Integer CORE_POOL_SIZE = 100;
    private static final ThreadFactory THREAD_FACTORY = Executors.defaultThreadFactory();
    private static final ScheduledExecutorService EXEC = new ScheduledThreadPoolExecutor(CORE_POOL_SIZE, THREAD_FACTORY);

    /** 外部线程中，安排中断 */
    public static void timedRun(Runnable runnable, long timeout, TimeUnit unit) {
        // 获取调用者线程
        final Thread task = Thread.currentThread();
        // 在一定时间后，将【调用者线程】标记为中断状态
        ScheduledFuture<?> schedule = EXEC.schedule(task::interrupt, timeout, unit);
        // 执行传入的 runnable 线程
        EXEC.execute(runnable);
    }
}
```

* **在中断线程之前，应该了解它的中断策略**。

* 由于 `timedRun` 可以从任意一个线程中调用，因此它无法知道这个调用线程的中断策略。例如：

    ```java
    import java.util.concurrent.ExecutionException;
    import java.util.concurrent.Executors;
    import java.util.concurrent.FutureTask;
    import java.util.concurrent.ScheduledExecutorService;
    import java.util.concurrent.ScheduledFuture;
    import java.util.concurrent.ScheduledThreadPoolExecutor;
    import java.util.concurrent.ThreadFactory;
    import java.util.concurrent.TimeUnit;
    
    public class TimedRun0 {
        public static void main(String[] args) throws InterruptedException {
            // 创建一个新的 task
            FutureTask<String> runImpl = new FutureTask<>(new RunImpl(), "runImpl");
            // 一定时间后，中断主线程，即 将main线程设为中断状态
            TimeRun.timedRun(runImpl, 1, TimeUnit.MILLISECONDS);
            // 调用者执行自己的逻辑
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("【main】线程执行了一些逻辑。 ------------------【main】计算结果 = 123");
            } else {
                System.out.println("【main】线程执行了一些逻辑。 ==================【main】计算结果 = abc");
            }
        }
    }
    
    
    /** 测试 runnable */
    class RunImpl implements Runnable {
        @Override
        public void run() {}
    }
    ```

    结果可能是：

    ```
    【main】线程执行了一些逻辑。 ------------------【main】计算结果 = 123
    ```

    ```
    【main】线程执行了一些逻辑。 ==================【main】计算结果 = abc
    ```

    

## 7. 通过 Future 取消任务

`Future<V>` 可以用来和已经提交的任务进行交互。`Future<V>` 接口定义了如下几个方法：

```java
public interface Future<V> {

    // 尝试取消执行此任务
    boolean cancel(boolean mayInterruptIfRunning);

    // 如果此任务在正常完成之前被取消，则返回 true 
    boolean isCancelled();

    // 如果任务已完成返回 true。
    boolean isDone();

    // 等待计算完成，然后检索其结果。
    V get() throws InterruptedException, ExecutionException;

    // 如果需要等待最多在给定的时间计算完成，然后检索其结果
    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
    
}
```



示例：

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * @author osys
 */
public class FutureTest01 {

    public static void main(String[] args) throws Exception {
        ExecutorService threadPool = Executors.newSingleThreadExecutor();

        // task 需要运行 3 秒
        SimpleTask task = new SimpleTask(3_000);
        Future<Double> future = threadPool.submit(task);
        threadPool.shutdown(); // 发送关闭线程池的指令

        double time = future.get();
        System.out.format("任务运行时间: %.3f s\n", time);

    }

    private static final class SimpleTask implements Callable<Double> {

        private final int sleepTime; // ms

        public SimpleTask(int sleepTime) {
            this.sleepTime = sleepTime;
        }

        @Override
        public Double call() throws Exception {
            double begin = System.nanoTime();

            Thread.sleep(sleepTime);

            double end = System.nanoTime();
            double time = (end - begin) / 1E9;

            return time; // 返回任务运行的时间，以 秒 计
        }

    }

}
```

如上，创建了一个 `SimpleTask`，该 `task` 运行时会休眠 3000ms，运行总时间会大于3000ms。

测试结果：

```
任务运行时间: 3.002 s
```



在上例基础上，通过 `Future.cancel()` 取消任务：

```java
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * @author osys
 */
public class FutureTest02 {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newSingleThreadExecutor();

        // task 需要运行 3 秒
        SimpleTask task = new SimpleTask(3_000);
        Future<Double> future = threadPool.submit(task);
        // 发送关闭线程池的指令
        threadPool.shutdown();

        // 在 2 秒之后取消该任务
        cancelTask(future, 2_000);

        try {
            double time = future.get();
            System.out.format("任务运行时间: %.3f s\n", time);
        } catch (CancellationException ex) {
            System.err.println("任务被取消");
        } catch (InterruptedException ex) {
            System.err.println("当前线程被中断");
        } catch (ExecutionException ex) {
            System.err.println("任务执行出错");
        }

    }

    private static void cancelTask(final Future<?> future, final int delay) {
        Runnable cancellation = () -> {
            try {
                Thread.sleep(delay);
                // 取消与 future 关联的正在运行的任务
                future.cancel(true);
            } catch (InterruptedException ex) {
                ex.printStackTrace(System.err);
            }
        };
        new Thread(cancellation).start();
    }

    private static final class SimpleTask implements Callable<Double> {
        // ms
        private final int sleepTime;

        public SimpleTask(int sleepTime) {
            this.sleepTime = sleepTime;
        }

        @Override
        public Double call() throws Exception {
            double begin = System.nanoTime();
            Thread.sleep(sleepTime);
            double end = System.nanoTime();
            double time = (end - begin) / 1E9;
            // 返回任务运行的时间，以 秒 计
            return time;
        }

    }
}
```

这里 task 的运行总时间会大于3000ms的，不过在 2 秒之后取消该任务。运行结果：

```
任务被取消
```



## 8. 调用 `Future` 的 `cancel(true)` 不一定能取消正在运行的任务

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * 判断一个数是否为素数
 * @author osys
 */
public class FutureTest03 {

    public static void main(String[] args) throws Exception {
        ExecutorService threadPool = Executors.newSingleThreadExecutor();

        long num = 1000000033L;
        PrimerTask task = new PrimerTask(num);
        Future<Boolean> future = threadPool.submit(task);
        threadPool.shutdown();

        // get result
        boolean result = future.get();
        System.out.format("%d 是否为素数？ %b\n", num, result);

    }

    // 判断一个数是否为素数
    private static final class PrimerTask implements Callable<Boolean> {
        private final long num;
        public PrimerTask(long num) {
            this.num = num;
        }
        @Override
        public Boolean call() {
            double begin = System.nanoTime();
            // i < num 让任务有足够的运行时间
            for (long i = 2; i < num; i++) {
                if (num % i == 0) {
                    return false;
                }
            }
            double end = System.nanoTime();
            double time = (end - begin) / 1E9;
            System.out.format("任务运行时间: %.3f s\n", time);
            return true;
        }

    }

}
```

Output:

```
任务运行时间: 15.033 s
1000000033 是否为素数？ true
```

任务的运行时间，大约是15.033 s



在任务运行到 2 秒的时候调用 `Future` 的 `cancel(true)` ：

```java
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * 判断一个数是否为素数
 * @author osys
 */
public class FutureTest04 {

    public static void main(String[] args) throws Exception {
        ExecutorService threadPool = Executors.newSingleThreadExecutor();

        long num = 1000000033L;
        PrimerTask task = new PrimerTask(num);
        Future<Boolean> future = threadPool.submit(task);
        // 发送关闭线程池的指令
        threadPool.shutdown();

        // 在 2 秒之后取消该任务
        cancelTask(future, 2_000);

        try {
            boolean result = future.get();
            System.out.format("%d 是否为素数？ %b\n", num, result);
        } catch (CancellationException ex) {
            System.err.println("任务被取消");
        } catch (InterruptedException ex) {
            System.err.println("当前线程被中断");
        } catch (ExecutionException ex) {
            System.err.println("任务执行出错");
        }
    }

    // 判断一个数是否为素数
    private static final class PrimerTask implements Callable<Boolean> {
        private final long num;
        public PrimerTask(long num) {
            this.num = num;
        }
        @Override
        public Boolean call() {
            double begin = System.nanoTime();
            // i < num 让任务有足够的运行时间
            for (long i = 2; i < num; i++) {
                if (num % i == 0) {
                    return false;
                }
            }
            double end = System.nanoTime();
            double time = (end - begin) / 1E9;
            System.out.format("任务运行时间: %.3f s\n", time);
            return true;
        }

    }

    // 在 delay ms 后取消 task
    private static void cancelTask(final Future<?> future, final int delay) {
        Runnable cancellation = () -> {
            try {
                Thread.sleep(delay);
                // 取消与 future 关联的正在运行的任务
                future.cancel(true);
            } catch (InterruptedException ex) {
                ex.printStackTrace(System.err);
            }
        };
        new Thread(cancellation).start();
    }
}
```

Output:

```
任务被取消
任务运行时间: 18.395 s
```

可以发现，虽然我们取消了任务，`Future` 的 `get` 方法也对我们的取消做出了响应（即抛出 `CancellationException` 异常），但是任务并没有停止，而是直到任务运行完毕了，程序才结束。



原因：

* 如上代码 `Future` 的 `get` 方法对我们的取消做出了响应：

    ```java
    catch (CancellationException ex) {
        System.err.println("任务被取消");
    }
    ```

    但是任务并没有停止，而是直到任务运行完毕了，程序才结束。

    

* 查看一下 `FutureTask.cancel()` 方法源码：

    ```java
    public boolean cancel(boolean mayInterruptIfRunning) {
        // 任务的运行状态，NEW
        // 查看当前任务，在内存中偏移量为 stateOffset 位置的值，是否等于 NEW
        // 如果偏移量为 stateOffset 位置的值等于 NEW，那么将其设置为 INTERRUPTING 或者 CANCELLED
        if (!(state == NEW &&
              UNSAFE.compareAndSwapInt(this, stateOffset, NEW,
                                       mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))
            // 任务偏移量为stateOffset位置的值 != NEW，且任务状态 != NEW
            return false;
        try {
            if (mayInterruptIfRunning) {
                try {
                    Thread t = runner;
                    if (t != null)
                        t.interrupt();
                } finally {
                    // 查看当前任务在内存中偏移量为 stateOffset 位置的值，将其值设置为 INTERRUPTED
                    UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);
                }
            }
        } finally {
            finishCompletion();
        }
        return true;
    }
    ```

    `Unsafe.class` 中的 `compareAndSwapInt()`方法和 `putOrderedInt()`方法：

    ```java
    public final class Unsafe {
        
        /**
         * 读取传入对象 var1 在内存中偏移量为 var2 位置的值与期望值 var4 作比较。
         * 相等就把 var5 值赋值给 var2 位置的值，方法返回true
         * 不相等，就取消赋值，方法返回false。
         */
        public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
        
        /**=
         * 读取传入对象 var1 在内存中偏移量为 var2 位置的值，将其设置为 var4
         */
        public native void putOrderedInt(Object var1, long var2, int var4);
    }
    ```

    

* 从 `FutureTask.cancel()` 源码可以知道，在运行状态下的任务，如果我们调用 `cancel()` 方法，传入 `true` 为参数，那么接下来会调用 `interrupt()` 方法将线程状态标记为中断状态。

  

* 将线程状态标记为中断状态，但不会终止线程，线程还会继续执行。



## 9. 对线程中断做出响应 的任务

如上 `FutureTest04` ，这里对线程中断作出响应操作

```java
private static final class PrimerTask implements Callable<Boolean> {
    private final long num;
    public PrimerTask(long num) {
        this.num = num;
    }
    @Override
    public Boolean call() {
        double begin = System.nanoTime();
        // i < num 让任务有足够的运行时间
        for (long i = 2; i < num; i++) {
            // 在每次进入循环时，进行判断，任务是否被取消
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("PrimerTask.call() task 被取消 ------- i = " + i);
                double end = System.nanoTime();
        		double time = (end - begin) / 1E9;
        		System.out.format("任务运行时间: %.3f s\n", time);
                return false;
            }
            if (num % i == 0) {
                return false;
            }
        }
        double end = System.nanoTime();
        double time = (end - begin) / 1E9;
        System.out.format("任务运行时间: %.3f s\n", time);
        return true;
    }

}
```

Output:

```
PrimerTask.call() task 被取消 ------- i = 154513461
任务运行时间: 2.151 s
任务被取消
```

通过 **`Thread.currentThread().isInterrupted()`** 方法，我们可以判断任务是否被取消，从而做出相应的取消任务的响应。



## 10. 处理不可中断阻塞

1. 并非所有的可阻塞方法或者阻塞机制都能响应中断。如果一个线程由于 `执行同步的Socket I/O` 或者 `等待获得内置锁` 而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用。

2. 由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因：

    * **java.io 包中的同步Socket I/O**。

        InputStream.read() 和 OutputStream.write() 等方法都不会响应中断，通过关闭底层的套接字，可以使得由于执行这些方法的线程被阻塞，抛出一个SocketException。

        

    * **java.nio 包中的同步I/O**。

        当中断一个正在 InterruptibleChannel 上等待的线程时，将抛出 ClosedByInterruptException 并关闭链路。

        当关闭一个 InterruptibleChannel 时，将导致所有在链路操作上阻塞的线程都抛出 AsynchronousCloseException。

        大多数的 Channel 都实现了 InterruptibleChannel。

        

    * **Selector 的异步I/O**。

        如果一个线程在调用 Selector.select() 方法时阻塞了，那么调用 close() 或 wakeup() 方法会使线程抛出ClosedSelectorException 并提前返回。

        

    * **获得锁**。

        如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断。在 Lock 类中提供了 lockInterruptibly() 方法，该方法允许在等待一个锁的同时仍能响应中断。



## 11. 如何封装非标准的取消操作

### 11.1 覆写 interrupt 来封裝非标准取消

在 Thread 中，通过覆写 interrupt 来封裝非标准取消

```java
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;

/**
 * @author osys
 */
public class ReaderThread extends Thread {
    private static final int BUFSZ = 512;
    private final Socket socket;
    private final InputStream in;

    public ReaderThread(Socket socket) throws IOException {
        this.socket = socket;
        this.in = socket.getInputStream();
    }

    public void interrupt() {
        try {
            socket.close();
        } catch (IOException ignored) {
        } finally {
            super.interrupt();
        }
    }

    public void run() {
        try {
            byte[] buf = new byte[BUFSZ];
            while (true) {
                int count = in.read(buf);
                if (count < 0) {
                    break;
                } else if (count > 0) {
                    processBuffer(buf, count);
                }
            }
        } catch (IOException e) {
            // 允许线程退出
        }
    }

    public void processBuffer(byte[] buf, int count) {
    }
}
```



## 11.2 用 newTaskFor 封装非标准的取消

1. newTaskFor 是一个工厂方法，它将创建 Future 来代表任务。
2. newTaskFor 还能返回一个 RunnableFuture 接口，该接口拓展了 Future 和 Runnable (并由FutureTask实现)。
3. 当把一个 Callable 提交给 ExecutorService 时，submit 方法会返回一个 Future，我们可以通过这个 Future 来取消任务。
4. 通过定制表示任务的 Future 可以改变 Future.cancel 的行为。

使用 newTaskFor 封装非标准的取消：

* 创建一个 Callable Interface

    ```java
    /**
     * CancellableTask
     * @param <T> result obj
     */
    interface CancellableTask <T> extends Callable<T> {
        void cancel();
    
        RunnableFuture<T> newTask();
    }
    ```

    

* 编写 CancellableTask 实现类

    ```java
    public abstract class SocketUsingTask <T> implements CancellableTask<T> {
        @GuardedBy("this")
        private Socket socket;
    
        protected synchronized void setSocket(Socket s) {
            socket = s;
        }
    
        public synchronized void cancel() {
            try {
                if (socket != null)
                    socket.close();
            } catch (IOException ignored) {
            }
        }
    
        /**
         * 创建一个 RunnableFuture，重写了 FutureTask.cancel() 方法
         * @return RunnableFuture
         */
        public RunnableFuture<T> newTask() {
            return new FutureTask<T>(this) {
                // 重写 FutureTask 的 cancel() 方法
                public boolean cancel(boolean mayInterruptIfRunning) {
                    try {
                        // cancel this SocketUsingTask
                        SocketUsingTask.this.cancel();
                    } finally {
                        return super.cancel(mayInterruptIfRunning);
                    }
                }
            };
        }
    }
    ```

    该实现类的 RunnableFuture.cancel() 方法，首先关闭当前对象套接字，随后关闭 RunnableFuture

    

* 复写一个 Executor，其 newTaskFor() 方法针对 obj 类型进行 return，RunnableFuture 类型返回 SocketUsingTask.newTask()

    ```java
    @ThreadSafe
    class CancellingExecutor extends ThreadPoolExecutor {
        public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
        }
    
        public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
        }
    
        public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
        }
    
        public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
        }
    
        protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
            if (callable instanceof CancellableTask) {
                return ((CancellableTask<T>) callable).newTask();
            } else {
                return super.newTaskFor(callable);
            }
        }
    }
    ```

    

