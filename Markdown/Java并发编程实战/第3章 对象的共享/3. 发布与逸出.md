## 1. 发布(Publish)

* 发布一个对象指的是，是对象能够再当前作用域之外的代码中使用。

  ```java
  import sun.nio.ch.Secrets;
  
  import java.util.HashSet;
  import java.util.Set;
  
  /**
   * @author osys
   */
  public class PublishObject {
  
      private static Set<Secrets> publishSecrets = new HashSet<>();
  
      public static Set<Secrets> getInstance() {
          return publishSecrets;
      }
  }
  ```



## 2. 逸出(Escape)

逸出：不应该发布的对象被发布



对于上面的代码：

```java
public class PublishObject {

    private static Set<Secrets> publishSecrets = new HashSet<>();

    public static Set<Secrets> getInstance() {
        return publishSecrets;
    }
}
```

* 当我们发布某个对象时，可能会间接地发布其他对象。
* 如我们不是发布 Set 对象，而是 `Secrets` 对象
* 如将别的 `Secrets` 对象添加到 `publishSecrets` 集合中，那么同样的，被添加的这个 `Secrets` 对象也会被发布。
* 因为任何使用者都能遍历这个集合，并且获得这个新 `Secrets` 对象的引用。



```java
public class UnsafeStates {
    private String[] states = new String[] {"a", "b", "c"};
    
    public String[] getStates() {
        return states;
    }
}
```

* 任何调用者都可能会修改发布的对象，如上 `states` 对象，该数组已经逸出了它所在的作用域。
* 当发布一个对象时，在该对象的非私有域应用的对象同样会被发布。
* 一般来说，如果一个已经发布的对象能够通过非私有的变量`引用`和`方法`调用到其他对象，那么这些对象也都会被发布。



## 3. 安全地对象构造

隐式地是由 this 引用逸出：

```java
/**
 * @author admin
 */
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(new EventListener() {
            @Override
            public void onEvent(Event event) {
                doSomething(event);
            }
        });
    }

    void doSomething(Event event) {
    }

    /** 事件源 */
    interface EventSource {
        /**
         * 注册事件监听
         * @param eventListener 事件监听
         */
        void registerListener(EventListener eventListener);
    }

    /** 事件监听 */
    interface EventListener {
        /**
         * 一个事件
         * @param event 一个事件
         */
        void onEvent(Event event);
    }

    /** 事件 */
    interface Event {
    }
}
```

* `ThisEscape` 中给出了逸出地一个特殊示例，即 `this` 引用在构造函数中逸出。
* 当内部地 `EventListener` 实例发布时，在外部封装的 `ThisEscape` 实例逸出了。
* 当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。
* 如果 `this` 引用在构造过程中逸出，那么这种对象就被认为是不正确的构造。



使用工厂方法来防止 `this` 引用在构造过程中逸出：

```java
/**
 * @author osys
 */
public class SafeListener {
    private final EventListener listener;
    
    private SafeListener() {
        listener = new EventListener() {
            @Override
            public void onEvent(Event event) {
                doSomething(event);
            }
        };
    }

    public static SafeListener newInstance(EventSource source) {
        SafeListener safeListener = new SafeListener();
        source.registerListener(safeListener.listener);
        return safeListener;
    }

    void doSomething(Event event) {
    }

    /** 事件源 */
    interface EventSource {
        /**
         * 注册事件监听
         * @param eventListener 事件监听
         */
        void registerListener(EventListener eventListener);
    }

    /** 事件监听 */
    interface EventListener {
        /**
         * 一个事件
         * @param event 一个事件
         */
        void onEvent(Event event);
    }

    /** 事件 */
    interface Event {
    }
}
```

如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个使用的构造函数和一个公共的工程方法，从而避免不正确的构造过程。