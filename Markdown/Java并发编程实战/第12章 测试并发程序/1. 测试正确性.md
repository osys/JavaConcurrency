## 1. 测试并发程序

并发程序打造可以分为两类：

1. 安全性测试
2. 活跃性测试
    * 进展性测试
    * 无进展测试

与活跃性测试相关的事**性能测试**。性能的衡量：

* 吞吐量
* 响应性
* 可伸缩性



## 2. 测试正确性

在为某个并发类设计单元测试时，首先需要执行与测试串行类时相同的分析 ---- 找出需要检查的不变性条件和后验条件。

```java
import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

import java.util.concurrent.Semaphore;

@ThreadSafe
public class SemaphoreBoundedBuffer <E> {
    /**
     * Semaphore ---- 计数信号量
     * availableItems ---- 可用items
     * availableSpaces ---- 可用空间
     */
    private final Semaphore availableItems, availableSpaces;

    /** 存放 Element 的数组 */
    @GuardedBy("this")
    private final E[] items;

    /**
     * putPosition ---- 存入数组 items 的位置
     * takePosition ---- 从数组中拿 Element 的位置
     */
    @GuardedBy("this")
    private int putPosition = 0, takePosition = 0;

    public SemaphoreBoundedBuffer(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException();
        }
        // 初始化幸好量，可用 items = 0，可用空间 spaces = capacity
        availableItems = new Semaphore(0);
        availableSpaces = new Semaphore(capacity);
        items = (E[]) new Object[capacity];
    }

    public boolean isEmpty() {
        return availableItems.availablePermits() == 0;
    }

    public boolean isFull() {
        return availableSpaces.availablePermits() == 0;
    }

    /**
     * 添加一个元素
     * 可用空间 - 1
     * 可用元素 + 1
     */
    public void put(E x) throws InterruptedException {
        availableSpaces.acquire();
        doInsert(x);
        availableItems.release();
    }

    /**
     * 拿出一个元素
     * 可用空间 + 1
     * 可用元素 - 1
     */
    public E take() throws InterruptedException {
        availableItems.acquire();
        E item = doExtract();
        availableSpaces.release();
        return item;
    }

    /**
     * 添加一个元素
     * @param x 元素
     */
    private synchronized void doInsert(E x) {
        int i = putPosition;
        items[i] = x;
        
        ++i;
        if (i == items.length) {
            putPosition = 0;
        } else {
            putPosition = i;
        }
    }

    private synchronized E doExtract() {
        int i = takePosition;
        E x = items[i];
        items[i] = null;

        ++i;
        if (i == items.length) {
            takePosition = 0;
        } else {
            takePosition = i;
        }
        return x;
    }
}
```

在计数信号量中，许可不会被显式地表现出来，也不会和它所在的线程有任何关联；release 创建许可，acquire消費许可。



### 2.1 基本的单元测试

对 SemaphoreBoundedBuffer 进行基本单元测试：

```java
public class TestBoundedBuffer extends TestCase {

    @Test
    public void testIsEmptyWhenConstructed() {
        SemaphoreBoundedBuffer<Integer> bb = new SemaphoreBoundedBuffer<Integer>(10);
        assertTrue(bb.isEmpty());		// bb.isEmpty() = true
        assertFalse(bb.isFull());		// bb.isFull() = false
    }

    @Test
    public void testIsFullAfterPuts() throws InterruptedException {
        SemaphoreBoundedBuffer<Integer> bb = new SemaphoreBoundedBuffer<Integer>(10);
        for (int i = 0; i < 10; i++) {
            bb.put(i);
        }
        assertTrue(bb.isFull());		// bb.isFull() = true
        assertFalse(bb.isEmpty());		// bb.isEmpty() = false
    }

}
```



### 2.2 测试阻塞操作

```java
import junit.framework.TestCase;
import org.junit.Test;

public class TestBoundedBuffer extends TestCase {
    private static final long LOCKUP_DETECT_TIMEOUT = 1000;

    @Test
    public void testTakeBlocksWhenEmpty() {
        final SemaphoreBoundedBuffer<Integer> bb = new SemaphoreBoundedBuffer<Integer>(10);
        Thread taker = new Thread() {
            public void run() {
                try {
                    int unused = bb.take();
                    fail();
                } catch (InterruptedException success) { }
            }
        };
        try {
            taker.start();
            Thread.sleep(LOCKUP_DETECT_TIMEOUT);
            taker.interrupt();
            taker.join(LOCKUP_DETECT_TIMEOUT);
            assertFalse(taker.isAlive());
        } catch (Exception unexpected) {
            fail();
        }
    }

}
```

如果在某个测试用例创建的辅助线程中发现了一个错误，那么框架通常无法得知与这个线程相关的是哪一个测试，所以需要通过一些工作将成功或失败信息传递回主线程，从而才能将相应的信息报告出来。



### 2.3 测试安全性

* 要想测试一个并发类在不可预知的并发访问下是否能够正确执行，我们可以安排多个线程对该并发类进行操作，运行一段时间再检查数据是否正常。
* 在对并发类进行安全性测试时，要关注某些熟悉可能会引发数据异常、导致程序出现问题。简单地识别出这些受检查的属性来，不要在检查这些属性，人为的限制程序的并发性。最好能做到在检查测试的属性时，不需要添加任何同步代码。

>SemaphoreBoundedBuffer 的生产者-消费者测试程序

```java
import junit.framework.TestCase;

import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

public class PutTakeTest extends TestCase {
    protected static final ExecutorService pool = Executors.newCachedThreadPool();
    protected CyclicBarrier barrier;
    protected final SemaphoreBoundedBuffer<Integer> bb;
    protected final int nTrials, nPairs;
    protected final AtomicInteger putSum = new AtomicInteger(0);
    protected final AtomicInteger takeSum = new AtomicInteger(0);

    public static void main(String[] args) throws Exception {
        new PutTakeTest(10, 10, 100000).test(); // sample parameters
        pool.shutdown();
    }

    public PutTakeTest(int capacity, int npairs, int ntrials) {
        this.bb = new SemaphoreBoundedBuffer<Integer>(capacity);
        this.nTrials = ntrials;
        this.nPairs = npairs;
        this.barrier = new CyclicBarrier(npairs * 2 + 1);
    }

    void test() {
        try {
            for (int i = 0; i < nPairs; i++) {
                pool.execute(new Producer());
                pool.execute(new Consumer());
            }
            barrier.await(); // wait for all threads to be ready
            barrier.await(); // wait for all threads to finish
            assertEquals(putSum.get(), takeSum.get());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    static int xorShift(int y) {
        y ^= (y << 6);
        y ^= (y >>> 21);
        y ^= (y << 7);
        return y;
    }

    /** 生产者 */
    class Producer implements Runnable {
        public void run() {
            try {
                int seed = (this.hashCode() ^ (int) System.nanoTime());
                int sum = 0;
                barrier.await();
                for (int i = nTrials; i > 0; --i) {
                    bb.put(seed);
                    sum += seed;
                    seed = xorShift(seed);
                }
                putSum.getAndAdd(sum);
                barrier.await();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    /** 消费者 */
    class Consumer implements Runnable {
        public void run() {
            try {
                barrier.await();
                int sum = 0;
                for (int i = nTrials; i > 0; --i) {
                    sum += bb.take();
                }
                takeSum.getAndAdd(sum);
                barrier.await();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```



### 2.4 测试资源管理

* 任何持有或管理着其他对象的对象，都应该在不需要某个对象时，放弃该对象的引用。
* 存储资源泄漏会抑制垃圾回收器回收内存(以及线程、文件句柄、套接字、数据库连接或者其它有限资源)，还会导致资源耗尽和应用程序的失败。因此要限制缓存的大小。
* 对内存不合理的占有，可以简单地通过堆检查工具测试出来。例如 JProfiler 工具。

> 测试资源泄漏

```java
import junit.framework.TestCase;
import org.junit.Test;

public class TestBoundedBuffer extends TestCase {
    private static final int CAPACITY = 10000;
    private static final int THRESHOLD = 10000;

    public class Big {
        double[] data = new double[100000];
    }

    @Test
    public void testLeak() throws InterruptedException {
        SemaphoreBoundedBuffer<Big> bb = new SemaphoreBoundedBuffer<>(CAPACITY);
        int heapSize1 = snapshotHeap();			// heap 的快照
        for (int i = 0; i < CAPACITY; i++) {
            bb.put(new Big());
        }
        for (int i = 0; i < CAPACITY; i++) {
            bb.take();
        }
        int heapSize2 = snapshotHeap();			// heap 的快照
        assertTrue(Math.abs(heapSize1 - heapSize2) < THRESHOLD);
    }

    private int snapshotHeap() {
        /* Snapshot heap and return heap size */
        return 0;
    }

}
```



### 2.5 使用回调

* 回调用户提供的代码，有助于创建测试用例；
* 回调常常发生在一个对象生命周期的己知点上，这些点提供了很好的机会，来断言不变约束。例如，ThreadPoolExecutor 就把调用转到了任务的 Runnable 和 ThreadFactory 上。
* 测试一个线程池，涉及到对其执行策路的大量要素的测试：当需要时就创建额外的线程，不需要时就不要创建；当需要时就回收空闲线程，等等。创建一个爱盖了所有可能性的全面的测试套件是一件非常好的事情，但是大多数可能性都可以简单地、独立地进行测试。

> 用于测试 ThreadPoolExecutor 的线程工厂

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

class TestingThreadFactory implements ThreadFactory {
    public final AtomicInteger numCreated = new AtomicInteger();
    private final ThreadFactory factory = Executors.defaultThreadFactory();

    public Thread newThread(Runnable r) {
        numCreated.incrementAndGet();
        return factory.newThread(r);
    }
}
```



> 验证线程池扩展的测试方法

```java
import junit.framework.TestCase;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

public class TestThreadPool extends TestCase {

    /** 线程工厂 */
    private final TestingThreadFactory threadFactory = new TestingThreadFactory();

    public void testPoolExpansion() throws InterruptedException {
        int MAX_SIZE = 10;
        ExecutorService exec = Executors.newFixedThreadPool(MAX_SIZE, threadFactory);

        // 提交 100 个 task 到 execute
        for (int i = 0; i < 10 * MAX_SIZE; i++) {
            exec.execute(new Runnable() {
                public void run() {
                    try {
                        Thread.sleep(Long.MAX_VALUE);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
        }
        for (int i = 0;
             i < 20 && threadFactory.numCreated.get() < MAX_SIZE;
             i++) {
            Thread.sleep(100);
        }
        // threadFactory.numCreated.get() = 10
        // MAX_SIZE = 10
        // junit.framework.AssertionFailedError: 
        assertEquals(threadFactory.numCreated.get(), MAX_SIZE);
        exec.shutdownNow();
    }
}
```

如果核心池大小小于最大值，线程池会在执行的任务增多时相应地增长。

向池提交几个耗时任务，会使池中的执行任务的数量在足够长的时间内都是常量，这就可以进行一些断言，比如测试池是否如期地扩展。



### 2.6 产生更多的交替操作

由于并发代码中发生的错误一般都是低概率事件，所以在测试并发错误时需要反复地执行许多次。

有些方法可以提高发现这些错误的概率，在多处理器系统上，如果处理器的数量少于活动线程的数量，那么与**单处理器的系统**或者**包含多个处理器的系统**相比，将能产生更多的交替行为。

同样，如果在不同的处理器数量、操作系统以及处理器架构的系统上进行测试，就可以发现那些在特定运行环境中才会出现的问题。

有一种有用的方法能提高交替操作的数量。以便能更有效的搜索程序的状态空间：在访问共享状态的操作中，使用**Thread.yield**将产生更多的上下文切换。当代码在访问状态的时候没有使用足够的同步，将存在一些对执行时序敏感的错误，通过在某个操作的执行过程 中调用yield方法，可以将这些错误暴露出来。这种方法需要在测试中添加一些调用并且在正式产品中删除这些调用。

> 使用 Thread.yield 产生更多的交替操作

```java
public synchronized void tranferCredits(Account from,Account to,int amount) {  
    from.setBalance(from.getBalance()-amount);  
    if (random.nextInt(1000)>THRESHOLD) {  
        Thread.yield();  
    }  
    to.setBalance(to.getBalance()+amount);  
}
```

