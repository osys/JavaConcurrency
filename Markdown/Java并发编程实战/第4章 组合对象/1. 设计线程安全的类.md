尽管将所有的状态都存储在公共静态域中，仍然能写出线程安全的程序。

在没有进行全局检查的情况下，封装能够保证类的线程安全性。



设计线程安全类的过程应该包括下面3个基本要素：

* 确定对象状态是由哪些变量构成的；
* 确定限制状态变量的不变约束；
* 制定一个管理并发访问对象状态的策略。



> 同步策略(Synchronization Policy)

定义了对象如何协调对其状态的访问，并且不会违反它的不便约束或验证条件。



使用 Java 监视器模式的简单线程安全计数器：

```java
import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

/**
 * @author osys
 */
@ThreadSafe
public final class Counter {
    @GuardedBy("this")
    private long value = 0;

    public synchronized long getValue() {
        return value;
    }

    public synchronized long increment() {
        if (value == Long.MAX_VALUE) {
            throw new IllegalStateException("counter overflow");
        }
        return ++value;
    }
}
```



> 收集同步需求

对象与变量拥有一个 **状态空间** ：这个空间即 `它们可能处于状态的范围`。

例如上面的：`Counter` 类

```java
// long 类型数据限制其范围是 Long.MIN_VALUE 到 Long.MAX_VALUE
private long value = 0;			// 限制了 value 的值必须是正值


if (value == Long.MAX_VALUE) {			// 是否非法
    throw new IllegalStateException("counter overflow");
}
return ++value;
```

类似地，操作的后验条件会指出某种 **状态转换(state transitions)** 是非法的

`不变约束` 与 `后验条件` 施加在状态及状态转换上的约束，引入了额外的同步与封装的需要。



>状态依赖的操作

* 类的 **不变约束** 与方法的 **后验条件** 约束了对象 `合法的状态` 和 `合法状态转换`
* 对象的方法也可以有 `先验条件`。如无法从空队列中移除一个条目。
* 单线程中，操作如果无法满足 `先验条件` 必然失败。
* 多线程中，原本为 `假` 的先验条件，可能会由于其它线程的活动变为 `真`。



在并发程序中，有**持续等待, 直到先验条件为真**，再继续处理的操作。在 Java 中，等待特定条件成立的内置高效机制 `wait` 和 `notify` 与内部锁紧密地绑定在一起。



> 状态所有权

* 在很多情况下，`所有权`与`封裝性`总是在一起出现的。

* 对象封装它拥有的状态，且拥有它封装的状态。拥有给定状态的所有者决定了锁协议，该协议用于维护变量状态的完整性。
* 所有权意味着`控制权`，不过一旦将引用发布到一个可变对象上，就不再拥有独占的控制权，充其量只可能有`共享控制权`。
* 类通常不会拥有由构造函数或方法传递进来的对象，除非该方法是被明确设计用来转换传递对象的所有权的（比如同步容器的包装`工厂方法`)。

