> 并发容器

Java5.0开始针对多线程并发访问设计，提供了并发性能较好的并发容器，引入了`java.util.concurrent`包。主要解决了两个问题：

1. 根据具体场景进行设计，尽量避免synchronized，提供并发性。
2. 定义了一些并发安全的复合操作，并且保证并发环境下的迭代操作不会出错。



> `ConcurrentHashMap`

* `ConcurrentHashMap`为了提高本身的并发能力，在内部采用了一个叫做`Segment`的结构，一个Segment其实就是一个类`HashTable`的结构，Segment内部维护了一个链表数组
* ConcurrentHashMap`定位一个元素`的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到**`元素所在链表的头部`**
* 该结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是`写操作`的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment
* ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。

构造方法如下：

```java
/**
 * initialCapacity --- 初始容量。给定指定的负载因子，实现执行内部大小调整以适应这么多元素。
 * loadFactor -------– 用于建立初始表大小的负载因子（表密度）
 * concurrencyLevel -– 估计的并发更新线程数。实现可以使用这个值作为大小提示。
 * m –---------------- Map<K, V>
 */
public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {}

public ConcurrentHashMap(int initialCapacity, float loadFactor) {}

public ConcurrentHashMap(Map<? extends K, ? extends V> m) {}

public ConcurrentHashMap() {}
```



> Map附加的原子操作

因为 `ConcurrentHashMap` 不能够在独占访问中被加锁，我们不能使用客户端加锁来创建新的原子操作。

不过一些常见的复合操作，比如`缺少即加入`，`相等便移除`和`相等便替换`，都已被实现为原子操作。

并且这些操作已在 `ConcurrentMap` 接口中声明，如下所示：

```java
public interface ConcurrentMap<K,V> extends Map<K, V> {
    // 只有当没有找到匹配K的值时才插入
    V putIfAbsent (K key, V value);
    
    // 只有当K与V匹配时才移除
    boolean remove (K key, V value);
    
    // 只有当K与 oldValue 匹配时才取代
    boolean replace (K key, V oldvalue, V newValue);
    
    // 只有当K匹配某值时才取代
    V replace(K key, V newValue);
}
```



> `CopyOnWrite` 容器

CopyOnWrite 通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。

优点：

* `CopyOnWrite容器` 是一种读写分离的思想，`读`和`写`不同的容器。
* 这种读写分离的思想，对于`并发的读`更友好。

不足：

* `CopyOnWrite容器` 写时复制机制，导致在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象。
* 如果这些对象占用的内存比较大，那么这个时候很有可能造成频繁的`Yong GC`和`Full GC`
* `CopyOnWrite容器` 只能保证数据的`最终`一致性，不能保证数据的`实时`一致性。

