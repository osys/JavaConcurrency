## 1. 并行递归算法

**如果每一个循环的每次迭代都睡觉哦独立的，并且我们不必等待所有的迭代都完成后再一次处理，那么我们可以使用 Executor 把一个顺序的循环转化为并行的循环。**

> 把顺序执行转换为并行执行

```java
import java.util.Collection;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public abstract class TransformingSequential {

    /** 顺序执行 */
    void processSequentially(List<Element> elements) {
        for (Element e : elements) {
            process(e);
        }
    }

    /** 并行执行 */
    void processInParallel(Executor exec, List<Element> elements) {
        for (final Element e : elements) {
            exec.execute(() -> process(e));
        }
    }

    public abstract void process(Element e);

    interface Element {
    }
}
```

当每个选代彼此独立，并且完成循环体中每个送代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的。



> 把顺序递归转化为并行递归

```java
import java.util.Collection;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public abstract class TransformingSequential {

	/** 顺序递归 */
    public <T> void sequentialRecursive(List<Node<T>> nodes,
                                        Collection<T> results) {
        for (Node<T> n : nodes) {
            results.add(n.compute());
            sequentialRecursive(n.getChildren(), results);
        }
    }

    /** 并行递归 */
    public <T> void parallelRecursive(final Executor exec,
                                      List<Node<T>> nodes,
                                      final Collection<T> results) {
        for (final Node<T> n : nodes) {
            exec.execute(() -> results.add(n.compute()));
            parallelRecursive(exec, n.getChildren(), results);
        }
    }

    /** 执行并行递归，获取结果 */
    public <T> Collection<T> getParallelResults(List<Node<T>> nodes)
            throws InterruptedException {
        ExecutorService exec = Executors.newCachedThreadPool();
        Queue<T> resultQueue = new ConcurrentLinkedQueue<T>();
        parallelRecursive(exec, nodes, resultQueue);
        exec.shutdown();
        exec.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
        return resultQueue;
    }

    interface Node <T> {
        T compute();
        List<Node<T>> getChildren();
    }
}
```



## 2. 示例：谜题框架

> “搬箱子” 谜题的抽象

```java
import java.util.Set;

/**
 * “搬箱子” 谜题的抽象
 * @param <P> 位置
 * @param <M> 移动
 */
public interface Puzzle <P, M> {
    /** 初始化 */
    P initialPosition();

    /** 移动位置是否为本位置 */
    boolean isGoal(P position);

    /** 合法移动 */
    Set<M> legalMoves(P position);

    /** 搬箱子 */
    P move(P position, M move);
}
```



> 谜题解决者框架的链节点

```java
import net.jcip.annotations.Immutable;

import java.util.LinkedList;
import java.util.List;

@Immutable
public class PuzzleNode <P, M> {
    /** 位置 */
    final P pos;
    /** 移动位置 */
    final M move;
    /** 上一个位置 */
    final PuzzleNode<P, M> prev;

    public PuzzleNode(P pos, M move, PuzzleNode<P, M> prev) {
        this.pos = pos;
        this.move = move;
        this.prev = prev;
    }

    /** 链表转集合 */
    List<M> asMoveList() {
        List<M> solution = new LinkedList<M>();
        for (PuzzleNode<P, M> node = this; node.move != null; node = node.prev) {
            solution.add(0, node.move);
        }
        return solution;
    }
}
```



> 顺序话版的谜题解决者

```java
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class SequentialPuzzleSolver <P, M> {
    private final Puzzle<P, M> puzzle;
    private final Set<P> seen = new HashSet<P>();

    public SequentialPuzzleSolver(Puzzle<P, M> puzzle) {
        this.puzzle = puzzle;
    }

    /** 解决者 */
    public List<M> solve() {
        P pos = puzzle.initialPosition();
        return search(new PuzzleNode<P, M>(pos, null, null));
    }

    /** 箱子移动 */
    private List<M> search(PuzzleNode<P, M> node) {
        // 该位置不存在箱子，或者箱子没有到过这个位置
        if (!seen.contains(node.pos)) {
            seen.add(node.pos);
            // 移动位置是否为本位置
            if (puzzle.isGoal(node.pos)) {
                return node.asMoveList();
            }
            // 获取每个合法移动
            for (M move : puzzle.legalMoves(node.pos)) {
                // 当前箱子位置移动
                P pos = puzzle.move(node.pos, move);
                // 下一个箱子移动
                PuzzleNode<P, M> child = new PuzzleNode<>(pos, move, node);
                List<M> result = this.search(child);
                if (result != null) {
                    return result;
                }
            }
        }
        return null;
    }
}
```



> 并发版的谜题解决者

```java
import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

public class ConcurrentPuzzleSolver <P, M> {

    /** 搬箱子谜题 */
    private final Puzzle<P, M> puzzle;
    private final ExecutorService exec;
    /** 箱子是否存在该位置 */
    private final ConcurrentMap<P, Boolean> seen;
    /** 可携带结果的闭锁 */
    protected final ValueLatch<PuzzleNode<P, M>> solution = new ValueLatch<>();

    public ConcurrentPuzzleSolver(Puzzle<P, M> puzzle) {
        this.puzzle = puzzle;
        // Return ThreadPoolExecutor Object
        this.exec = initThreadPool();
        this.seen = new ConcurrentHashMap<P, Boolean>();
        if (exec instanceof ThreadPoolExecutor) {
            ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) exec;
            // 被拒绝任务，它默默地丢弃被拒绝的任务。
            threadPoolExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
        }
    }

    private ExecutorService initThreadPool() {
        return Executors.newCachedThreadPool();
    }

    /** 解决者 */
    public List<M> solve() throws InterruptedException {
        try {
            P p = puzzle.initialPosition();
            exec.execute(newTask(p, null, null));
            // 阻塞，知道找到一个方案
            PuzzleNode<P, M> solutionPuzzleNode = solution.getValue();
            return (solutionPuzzleNode == null) ? null : solutionPuzzleNode.asMoveList();
        } finally {
            exec.shutdown();
        }
    }

    protected Runnable newTask(P position, M move, PuzzleNode<P, M> puzzleNode) {
        return new SolverTask(position, move, puzzleNode);
    }

    protected class SolverTask extends PuzzleNode<P, M> implements Runnable {
        SolverTask(P pos, M move, PuzzleNode<P, M> prev) {
            super(pos, move, prev);
        }

        public void run() {
            // 已找到一个解决方案，或者该位置曾经到达过
            if (solution.isSet() || seen.putIfAbsent(pos, true) != null) {
                return;
            }
            // 移动位置是否为本位置
            if (!puzzle.isGoal(pos)) {
                // 获取每个合法移动
                for (M move : puzzle.legalMoves(pos)) {
                    exec.execute(
                            // 创建一个新的 task 进行位置移动
                            newTask(puzzle.move(pos, move),
                                    move,
                                    this)
                    );
                }
            } else {
                // 移动位置为本位置
                solution.setValue(this);
            }
        }
    }
}
```



> ConcurrentPuzzleSolver 使用可携带结果的闭锁

```java
@ThreadSafe
public class ValueLatch <T> {
    @GuardedBy("this")
    private T value = null;
    /** 一种同步辅助，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。 */
    private final CountDownLatch done = new CountDownLatch(1);

    public boolean isSet() {
        return (done.getCount() == 0);
    }

    public synchronized void setValue(T newValue) {
        if (!isSet()) {
            value = newValue;
            // Decrease ---> 【done.getCount() - 1】
            done.countDown();
        }
    }

    public T getValue() throws InterruptedException {
        // 当前线程等待直到锁存器倒计时到零
        done.await();
        synchronized (this) {
            return value;
        }
    }
}
```

