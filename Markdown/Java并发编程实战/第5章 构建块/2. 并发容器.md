> 并发容器

Java5.0开始针对多线程并发访问设计，提供了并发性能较好的并发容器，引入了`java.util.concurrent`包。主要解决了两个问题：

1. 根据具体场景进行设计，尽量避免synchronized，提供并发性。
2. 定义了一些并发安全的复合操作，并且保证并发环境下的迭代操作不会出错。



> `ConcurrentHashMap`

* `ConcurrentHashMap`为了提高本身的并发能力，在内部采用了一个叫做`Segment`的结构，一个Segment其实就是一个类`HashTable`的结构，Segment内部维护了一个链表数组
* ConcurrentHashMap`定位一个元素`的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到**`元素所在链表的头部`**
* 该结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是`写操作`的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment
* ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。

构造方法如下：

```java
/**
 * initialCapacity - 初始容量。给定指定的负载因子，实现执行内部大小调整以适应这么多元素。
 * loadFactor – 用于建立初始表大小的负载因子（表密度）
 * concurrencyLevel – 估计的并发更新线程数。实现可以使用这个值作为大小提示。
 */
public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)

public ConcurrentHashMap(int initialCapacity, float loadFactor)
```

